{"version":3,"file":"static/js/227.d15b6563.chunk.js","mappings":"qKAMA,IAAMA,EAAa,CACjB,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,OAKvCC,EAAW,CACfC,EAAG,CACD,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,IAEPC,EAAG,CACD,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,IAEPC,EAAG,CACD,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,IAEPC,EAAG,CACD,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,IAEPC,EAAG,CACD,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,IAEPC,EAAG,CACD,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,IAEPC,EAAG,CACD,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,IAEPC,EAAG,CACD,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,I,2HCvFHC,G,OAAwB,SAACC,EAAYC,EAAUC,EAAYC,EAAUC,GAGzE,IAAIC,EAAS,GACTC,EAAQ,GACRC,EAAQ,GAEZ,GAAIP,IAAeC,GAAYC,IAAeC,EAC5C,MAAO,CAAEE,OAAQL,EAAaE,EAAYI,MAAAA,EAAOC,MAAAA,GAGnD,IAAIC,EAAoBR,EAAWS,WAAW,GAC1CC,EAAkBT,EAASQ,WAAW,GACtCE,EAAgBC,SAASV,GACzBW,EAAcD,SAAST,GAGvBW,EAAkBN,EAAoB,EACtCO,EAAkBP,EAAoB,EACtCQ,EAAcL,EAAgB,EAC9BM,EAAcN,EAAgB,EAE5BO,EAAiB,IAAIT,WAAW,GAChCU,EAAiB,IAAIV,WAAW,GAItC,GAAIC,EAAkBF,GAAqBK,EAAcF,EACvD,MAAQG,GAAmBJ,GACzBI,GAAmBI,GAClBF,GAAeH,GAAeG,GANhB,KASfV,EAAQF,GADRC,EAASe,OAAOC,aAAaP,GAAmBE,EAAYM,YACpC,IAAIjB,EAAO,IACnCE,EAAQgB,EAAcjB,GACR,KAAVA,IAEFQ,IACAE,SASD,GAAIN,EAAkBF,GAAqBK,EAAcF,EAC5D,MAAQG,GAAmBJ,GACzBI,GAAmBI,GAClBD,GAAeJ,GAAeI,GAzBhB,KA4BfX,EAAQF,GADRC,EAASe,OAAOC,aAAaP,GAAmBG,EAAYK,YACpC,IAAIjB,EAAO,IACnCE,EAAQgB,EAAcjB,GACR,KAAVA,IAEFQ,IACAG,SASD,GAAIP,EAAkBF,GAAqBK,EAAcF,EAC5D,MAAQI,GAAmBL,GACzBK,GAAmBI,GAClBH,GAAeH,GAAeG,GA9ChB,KAiDfV,EAAQF,GADRC,EAASe,OAAOC,aAAaN,GAAmBC,EAAYM,YACpC,IAAIjB,EAAO,IACnCE,EAAQgB,EAAcjB,GACR,KAAVA,IAEFS,IACAC,SASD,GAAIN,EAAkBF,GAAqBK,EAAcF,EAC5D,MAAQI,GAAmBL,GACzBK,GAAmBI,GAClBF,GAAeJ,GAAeI,GAjEhB,KAoEfX,EAAQF,GADRC,EAASe,OAAOC,aAAaN,GAAmBE,EAAYK,YACpC,IAAIjB,EAAO,IACnCE,EAAQgB,EAAcjB,GACR,KAAVA,IAEFS,IACAE,IAQN,MAAO,CAAEZ,OAAAA,EAAQC,MAAAA,EAAOC,MAAAA,EAC1B,GA8CMiB,EAAmB,SAACtB,EAAYC,EAAUsB,EAAMrB,GAGpD,IAAIC,EAAS,GACTC,EAAQ,GACRC,EAAQ,GAEZ,GAAIL,IAAeC,EACjB,MAAO,CAAEE,OAAQoB,EAAOvB,EAAYI,MAAAA,EAAOC,MAAAA,GAG7C,IAAMI,EAAgBC,SAASV,GACzBW,EAAcD,SAAST,GAGzBuB,EAAWf,EAAgB,EAC3BgB,EAAWhB,EAAgB,EAE/B,GAAIA,EAAgBE,EAClB,KAAea,GAAYb,IAGzBP,EAAQF,GADRC,EAASoB,EAAOC,EAASJ,YACD,IAAIjB,EAAO,IACnCE,EAAQgB,EAAcjB,GACR,KAAVA,GALkCoB,UAiBxC,KAAeC,GAAYd,IAGzBP,EAAQF,GADRC,EAASoB,EAAOE,EAASL,YACD,IAAIjB,EAAO,IACnCE,EAAQgB,EAAcjB,GACR,KAAVA,GALkCqB,KAe1C,MAAO,CAAEtB,OAAAA,EAAQC,MAAAA,EAAOC,MAAAA,EAC1B,EAQMqB,EAAmB,SAAC5B,EAAYC,EAAU4B,EAAMzB,GAGpD,IAAIC,EAAS,GACTC,EAAQ,GACRC,EAAQ,GAEZ,GAAIP,IAAeC,GAAYG,EAC7B,MAAO,CAAEC,OAAQL,EAAa6B,EAAMvB,MAAAA,EAAOC,MAAAA,GAG7C,IAAIC,EAAoBR,EAAWS,WAAW,GAC1CC,EAAkBT,EAASQ,WAAW,GAGtCK,EAAkBN,EAAoB,EACtCO,EAAkBP,EAAoB,EAE1C,GAAIA,EAAoBE,EACtB,KAAsBI,GAAmBJ,IAGvCJ,EAAQF,GADRC,EAASe,OAAOC,aAAaP,GAAmBe,GACxB,IAAIxB,EAAO,IACnCE,EAAQgB,EAAcjB,GACR,KAAVA,GALoDQ,UAiB1D,KAAsBC,GAAmBL,IAGvCJ,EAAQF,GADRC,EAASe,OAAOC,aAAaN,GAAmBc,GACxB,IAAIxB,EAAO,IACnCE,EAAQgB,EAAcjB,GACR,KAAVA,GALoDS,KAe5D,MAAO,CAAEV,OAAAA,EAAQC,MAAAA,EAAOC,MAAAA,EAC1B,EAKMuB,EAAa,SAACC,EAAcC,GAEhC,MAA6DC,EAAqBF,EAAcC,GAAe,eAAxGhC,EAAU,KAAEE,EAAU,KAAEgC,EAAY,KAAEC,EAAY,KACzD,EAAyCC,EAA0BpC,EAAYE,EAAYgC,EAAcC,GAAa,eAA/GE,EAAc,KAErB,GAAIA,IAFiC,MAEuB,IAAnBA,EACvC,OAAO,EAGT,GAAIrC,IAAekC,GACjB,GAAgE,IAA5DI,KAAKC,IAAI3B,SAASV,GAAcU,SAASuB,IAC3C,OAAO,OAIN,GAAIjC,IAAeiC,GACkD,IAApEG,KAAKC,IAAIvC,EAAWS,WAAW,GAAKyB,EAAazB,WAAW,IAC9D,OAAO,EAIX,OAAO,CACT,EAMM+B,EAAgB,SAACC,EAAeC,EAAeC,EAAoBC,EAAkBC,GAEzF,OAAIF,IAAuBD,MAKL,MAAlBA,IAAyBG,EAAiBC,SAASL,OAG5B,MAAlBC,IACPE,EAAiBE,SAASL,IAK9B,EAKMM,EAAiB,SAACzC,EAAO0C,EAAQC,EAAM7C,GAC3C,MAAqD6B,EAAqBe,EAAQC,GAAK,eAAhFjD,EAAU,KAAEE,EAAU,KAAED,EAAQ,KAAEE,EAAQ,KAC7C+C,EAAmBC,KAAKC,MAAMD,KAAKE,UAAUjD,IAIjD,OAFA8C,EAAiBlD,GAAYE,GAAc,GAC3CgD,EAAiBjD,GAAUE,GAAYG,EAChC4C,CACT,EACM3B,EAAgB,SAACjB,GACrB,MAAc,KAAVA,EACK,GAGFA,EAAMgD,gBAAkBhD,EAAQ,IAAH,GACtC,EAKM2B,EAAuB,SAACe,EAAQC,GACpC,MAAiCM,EAAeP,GAAO,eAAhDhD,EAAU,KAAEE,EAAU,KAC7B,EAA6BqD,EAAeN,GAAK,eACjD,MAAO,CAACjD,EAAYE,EADL,KAAU,KAE3B,EAKMkC,EAA4B,SAACpC,EAAYE,EAAYD,EAAUE,GAGnE,MAAO,CAFgBmC,KAAKC,IAAIvC,EAAWS,WAAW,GAAKR,EAASQ,WAAW,IACxD6B,KAAKC,IAAI3B,SAASV,GAAcU,SAAST,IAElE,EACMoD,EAAiB,SAAClD,GAEtB,OAAsB,IAAlBA,EAAOmD,QAA+C,kBAAxB5C,SAASP,EAAO,KAChDoD,QAAQC,MAAM,wBACP,CAAC,KAAM,OAET,CAACrD,EAAO,GAAIA,EAAO,GAC5B,EAyBMsD,EAAkB,SAAClC,EAAMI,EAAMtB,EAAOqD,EAAWxD,GACrD,IACIyD,EAAqB,CACvBxD,OAAQ,GACRC,MAAO,GACPC,MAAO,IAgBT,MAbkB,OAAdqD,EACFC,EAAqBrC,EAAiBK,EAAM,IAAKJ,EAAMrB,GAElC,SAAdwD,IACPC,EAAqBrC,EAAiBK,EAAM,IAAKJ,EAAMrB,GACzC,MAAVG,GAA8C,MAA7BsD,EAAmBvD,QACtCuD,EAAqBrC,GAAkBZ,SAASiB,GAAQ,GAAGP,WAAY,IAAKG,EAAMrB,IAEtE,MAAVG,GAA8C,MAA7BsD,EAAmBvD,QACtCuD,EAAqBrC,GAAkBZ,SAASiB,GAAQ,GAAGP,WAAY,IAAKG,EAAMrB,QAIlF0B,EAAWL,EAAOI,EAAMgC,EAAmBxD,UAEnCmC,EAAcqB,EAAmBvD,MAAOC,EAAOsD,EAAmBtD,MAAO,CAAC,IAAK,IAAK,KAAM,CAAC,IAAK,IAAK,UAMvGiC,EAAcqB,EAAmBvD,MAAOC,EAAOsD,EAAmBtD,MAAO,CAAC,IAAK,KAAM,CAAC,IAAK,KAMvG,EAMMuD,EAAoB,SAACrC,EAAMI,EAAMtB,EAAOqD,EAAWxD,GACvD,IACIyD,EAAqB,CACvBxD,OAAQ,GACRC,MAAO,GACPC,MAAO,IAUT,MAPkB,SAAdqD,EACFC,EAAqBjC,EAAiBH,EAAM,IAAKI,EAAMzB,GAElC,UAAdwD,IACPC,EAAqBjC,EAAiBH,EAAM,IAAKI,EAAMzB,OAGrD0B,EAAWL,EAAOI,EAAMgC,EAAmBxD,UAEnCmC,EAAcqB,EAAmBvD,MAAOC,EAAOsD,EAAmBtD,MAAO,CAAC,IAAK,IAAK,KAAM,CAAC,IAAK,IAAK,UAMvGiC,EAAcqB,EAAmBvD,MAAOC,EAAOsD,EAAmBtD,MAAO,CAAC,IAAK,KAAM,CAAC,IAAK,KAMvG,EAKMwD,EAAU,SAACC,EAAaC,EAAS7D,GAErC,OAAI6D,EAAU,GACZA,EAAU,GACVD,EAAc,IAAIvD,WAAW,IAC7BuD,EAAc,IAAIvD,WAAW,GACtB,GAEFL,EAASgB,OAAOC,aAAa2C,IAAcC,EAAQ3C,WAC5D,EA2EM4C,EAAkB,SAACzC,EAAMI,EAAMtB,EAAOqD,EAAWxD,GAErD,IAEIyD,EAFJ,EAjbsB,SAACxD,EAAQuD,GAC/B,MAAqBL,EAAelD,GAAO,eAApCoB,EAAI,KAAEI,EAAI,KACbmC,EAAcvC,EAAKhB,WAAW,GAC9BwD,EAAUrD,SAASiB,GACjBX,EAAiB,IAAIT,WAAW,GAChCU,EAAiB,IAAIV,WAAW,GAGtC,GAAkB,aAAdmD,EACF,KAAOI,EAAc9C,GAAkB+C,EAHzB,GAIZD,IACAC,SAGC,GAAkB,eAAdL,EACP,KAAOI,EAAc9C,GAAkB+C,EARzB,GASZD,IACAC,SAGC,GAAkB,YAAdL,EACP,KAAOI,EAAc7C,GAAkB8C,EAfzB,GAgBZD,IACAC,SAGC,GAAkB,cAAdL,EACP,KAAOI,EAAc7C,GAAkB8C,EApBzB,GAqBZD,IACAC,IAGJ,MAAO,CAAC7C,OAAOC,aAAa2C,GAAcC,EAAQE,UACpD,CAgZ6CC,CAAgB3C,EAAOI,EAAM+B,GAAU,eAA7ES,EAAgB,KAAEC,EAAgB,KAUvC,GAFAT,EAAqB9D,EAAsB0B,EAAM4C,EAAkBxC,EAAMyC,EAAkBlE,GAEvF0B,EAAWL,EAAOI,EAAMgC,EAAmBxD,QAAS,CAEtD,GApCoB,SAACE,EAAOgE,EAAMX,GAEpC,MAAc,MAAVrD,GACO,MAATgE,IACe,aAAdX,GAA0C,YAAdA,IAIZ,MAAVrD,GACE,MAATgE,IACe,eAAdX,GAA4C,cAAdA,EAKnC,CAqBQY,CAAgBjE,EAAOsD,EAAmBvD,MAAOsD,GACnD,OAAO,EAIT,GADUpB,EAAcqB,EAAmBvD,MAAOC,EAAOsD,EAAmBtD,MAAO,CAAC,IAAK,IAAK,KAAM,CAAC,IAAK,IAAK,MAE7G,OAAO,CAEX,CAGA,QADUiC,EAAcqB,EAAmBvD,MAAOC,EAAOsD,EAAmBtD,MAAO,CAAC,IAAK,KAAM,CAAC,IAAK,KAMvG,EAIMkE,EAAU,SAACpE,EAAQE,EAAOH,GAE9B,MAAqBmD,EAAelD,GAAO,eAApCoB,EAAI,KAAEI,EAAI,KAEjB,QAAI8B,EAAgBlC,EAAMI,EAAMtB,EAAO,KAAMH,OAEzCuD,EAAgBlC,EAAMI,EAAMtB,EAAO,OAAQH,OAG3C0D,EAAkBrC,EAAMI,EAAMtB,EAAO,QAASH,OAE9C0D,EAAkBrC,EAAMI,EAAMtB,EAAO,OAAQH,OAG7C8D,EAAgBzC,EAAMI,EAAMtB,EAAO,WAAYH,OAE/C8D,EAAgBzC,EAAMI,EAAMtB,EAAO,aAAcH,OAEjD8D,EAAgBzC,EAAMI,EAAMtB,EAAO,UAAWH,OAE9C8D,EAAgBzC,EAAMI,EAAMtB,EAAO,YAAaH,MA5H5B,SAACqB,EAAMI,EAAMtB,EAAOH,GAC5C,IAAM4D,EAAcvC,EAAKhB,WAAW,GAC9BwD,EAAUrD,SAASiB,GAEzB,MAAc,MAAVtB,EACsD,MAApDwD,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,GAI9B,MAAVG,EACsD,MAApDwD,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,IAEc,MAApD2D,EAAQC,EAAc,EAAGC,EAAU,EAAG7D,QAf5C,CAmBF,CAqFMsE,CAAkBjD,EAAMI,EAAMtB,EAAOH,SAI3C,EA4NMuE,EAAS,WACb,cAAc,eAEZC,KAAKxE,UAAWyE,EAAAA,EAAAA,KAChBD,KAAKE,YAAa,EAClBF,KAAKG,YAAc,GACnBH,KAAKI,mBAAqB,GAC1BJ,KAAKK,iBAAmB,GACxBL,KAAKM,kBAAoB,GACzBN,KAAKO,kBAAoB,EAAC,EAAO,IACjCP,KAAKQ,kBAAoB,EAAC,EAAO,IACjCR,KAAKS,wBAAyB,EAC9BT,KAAKU,yBAA0B,EAC/BV,KAAKW,wBAAyB,EAC9BX,KAAKY,yBAA0B,EAC/BZ,KAAKa,aAAc,EACnBb,KAAKc,mBAAqB,KAC1Bd,KAAKe,mBAAqB,IAC5B,CA4cC,OA3cD,mCAGA,SAAYC,GAEV,IAAMC,EAAkB9C,EAAe6C,EAAkBhB,KAAKI,mBAAoBJ,KAAKK,iBAAkBL,KAAKxE,UAC9GwE,KAAKxE,SAAW+C,KAAKC,MAAMD,KAAKE,UAAUwC,IAE1CjB,KAAKE,YAAcF,KAAKE,UAC1B,GACA,qBAGA,WAEE,IAAMe,EAAkB9C,EAAe6B,KAAKG,YAAaH,KAAKI,mBAAoBJ,KAAKK,iBAAkBL,KAAKxE,UAC9GwE,KAAKxE,SAAW+C,KAAKC,MAAMD,KAAKE,UAAUwC,IAE1CjB,KAAKE,YAAcF,KAAKE,UAC1B,GACA,0BAIA,SAAa9B,EAAQC,EAAM3C,GAEzB,IAAIwF,GAAU,EACVC,GAAc,EACdC,GAAW,EACXC,GAAc,EAClB,GAAIjD,IAAWC,EACb,MAAO,CAAE6C,QAAAA,EAASC,YAAAA,EAAaC,SAAAA,EAAUC,YAAAA,GAK3C,IAAIC,EAAYtB,KAAKM,kBAGrB,GAFAN,KAAKM,kBAAoB3D,EAAcjB,GAEnCsE,KAAKE,YAAyC,MAA3BF,KAAKM,kBAC1B,MAAO,CAAEY,QAAAA,EAASC,YAAAA,EAAaC,SAAAA,EAAUC,YAAAA,GAEtC,IAAKrB,KAAKE,YAAyC,MAA3BF,KAAKM,kBAChC,MAAO,CAAEY,QAAAA,EAASC,YAAAA,EAAaC,SAAAA,EAAUC,YAAAA,GAG3C,GAAIrB,KAAKa,YACP,MAAO,CAAEK,QAAAA,EAASC,YAAAA,EAAaC,SAAAA,EAAUC,YAAAA,GAG3C,OAAQ3F,GACN,IAAK,IAAL,MAC2BsE,KAAKuB,iBAAiBnD,EAAQC,EAAM,KAA1D6C,EAAO,EAAPA,QAASE,EAAQ,EAARA,SACZ,MACF,IAAK,IAAG,MACmBpB,KAAKuB,iBAAiBnD,EAAQC,EAAM,KAA1D6C,EAAO,EAAPA,QAASE,EAAQ,EAARA,SACZ,MACF,IAAK,IACHF,EAAUlB,KAAKwB,kBAAkBpD,EAAQC,EAAM,KAC/C,MACF,IAAK,IACH6C,EAAUlB,KAAKwB,kBAAkBpD,EAAQC,EAAM,KAC/C,MACF,IAAK,IACH6C,EAAUlB,KAAKyB,iBAAiBrD,EAAQC,EAAM,KAC9C,MACF,IAAK,IACH6C,EAAUlB,KAAKyB,iBAAiBrD,EAAQC,EAAM,KAC9C,MACF,IAAK,IACH6C,EAAUlB,KAAK0B,mBAAmBtD,EAAQC,EAAM,KAChD,MACF,IAAK,IACH6C,EAAUlB,KAAK0B,mBAAmBtD,EAAQC,EAAM,KAChD,MACF,IAAK,IACH6C,EAAUlB,KAAK2B,mBAAmBvD,EAAQC,EAAM,KAChD,MACF,IAAK,IACH6C,EAAUlB,KAAK2B,mBAAmBvD,EAAQC,EAAM,KAChD,MACF,IAAK,IAAG,MACmC2B,KAAK4B,iBAAiBxD,EAAQC,EAAM,KAA1E6C,EAAO,EAAPA,QAASC,EAAW,EAAXA,YAAaE,EAAW,EAAXA,YACzB,MACF,IAAK,IAAG,MACmCrB,KAAK4B,iBAAiBxD,EAAQC,EAAM,KAA1E6C,EAAO,EAAPA,QAASC,EAAW,EAAXA,YAAaE,EAAW,EAAXA,YAG7B,GAAIH,EAAS,CAEG,MAAVxF,GACFsE,KAAKc,mBAAqBzC,EAC1B2B,KAAKS,wBAAyB,EAC9BT,KAAKU,yBAA0B,GAEd,MAAVhF,IACPsE,KAAKe,mBAAqB1C,EAC1B2B,KAAKW,wBAAyB,EAC9BX,KAAKY,yBAA0B,GAGjC,IAAMiB,EAAetD,KAAKC,MAAMD,KAAKE,UAAUuB,KAAKxE,WAG9CsG,EArkBG,SAACpG,EAAO0C,EAAQC,EAAMyC,EAAoBC,EAAoBvF,GAC3E,IAAMyF,EAAkB9C,EAAezC,EAAO0C,EAAQC,EAAM7C,GACtDG,EAAQgB,EAAcjB,GAI5B,MAAc,MAAVC,GACMkE,EAAQiB,EAAoB,IAAKG,GAE7B,MAAVtF,GACMkE,EAAQkB,EAAoB,IAAKE,QAD3C,CAGF,CAyjBqCc,CAAOrG,EAAO0C,EAAQC,EAAM2B,KAAKc,mBAAoBd,KAAKe,mBAAoBc,GAC7G,OAAKC,EAIDV,GACY,MAAV1F,GACFsE,KAAKxE,SAAY,EAAE,GAAO,GACb,OAAT6C,GAA0B,OAATA,GACnB2B,KAAKxE,SAAY,EAAE,GAAO,IAC1BwE,KAAKxE,SAAY,EAAE,GAAO,IAC1BwE,KAAKxE,SAAY,EAAE,GAAO,IAEV,OAAT6C,GAA0B,OAATA,IACxB2B,KAAKxE,SAAY,EAAE,GAAO,IAC1BwE,KAAKxE,SAAY,EAAE,GAAO,IAC1BwE,KAAKxE,SAAY,EAAE,GAAO,KAGX,MAAVE,IACPsE,KAAKxE,SAAY,EAAE,GAAO,GACb,OAAT6C,GAA0B,OAATA,GACnB2B,KAAKxE,SAAY,EAAE,GAAO,IAC1BwE,KAAKxE,SAAY,EAAE,GAAO,IAC1BwE,KAAKxE,SAAY,EAAE,GAAO,IAEV,OAAT6C,GAA0B,OAATA,IACxB2B,KAAKxE,SAAY,EAAE,GAAO,IAC1BwE,KAAKxE,SAAY,EAAE,GAAO,IAC1BwE,KAAKxE,SAAY,EAAE,GAAO,KAI9BwE,KAAKE,YAAcF,KAAKE,WACjB,CAAEgB,QAAAA,EAASC,YAAAA,EAAaC,SAAAA,EAAUC,YAAAA,KAEvCA,IAGAF,IACY,MAAVzF,EACFsE,KAAKxE,SAAS6C,EAAK,KAAKrC,SAASqC,EAAK,IAAM,GAAG3B,YAAc,GAE5C,MAAVhB,IACPsE,KAAKxE,SAAS6C,EAAK,KAAKrC,SAASqC,EAAK,IAAM,GAAG3B,YAAc,KAGjD,MAAVhB,GAA2B,MAAVA,IACrBsE,KAAKQ,kBAAoB,EAAC,EAAO,IACjCR,KAAKO,kBAAoB,EAAC,EAAO,KAGnCP,KAAKG,YAAczE,EACnBsE,KAAKI,mBAAqBhC,EAC1B4B,KAAKK,iBAAmBhC,EAExB2B,KAAKgC,WAnBI,CAAEd,QAAAA,EAASC,YAAAA,EAAaC,SAAAA,EAAUC,YAAAA,IAnClC,CAAEH,SAAS,EAAOC,YAAAA,EAAaC,SAAAA,EAAUC,YAAAA,EAwDpD,CAIA,OADArB,KAAKM,kBAAoBgB,EAClB,CAAEJ,QAAAA,EAASC,YAAAA,EAAaC,SAAAA,EAAUC,YAAAA,EAC3C,GACA,8BAIA,SAAiBjD,EAAQC,EAAM1C,GAE7B,IAAMsG,EAAmB5E,EAAqBe,EAAQC,GAClD6C,GAAU,EACVgB,GAAgB,EAChBC,GAAgB,EACpB,GAAIF,EAAiB/D,SAAS,MAE5B,OADAW,QAAQuD,IAAI,wBACL,CAAElB,QAAAA,EAASC,YAAae,EAAeb,YAAac,GAG7D,cAAqDF,EAAgB,GAA9D7G,EAAU,KAAEE,EAAU,KAAED,EAAQ,KAAEE,EAAQ,KACjD,EAAyCiC,EAA0BpC,EAAYE,EAAYD,EAAUE,GAAS,eAAvGkC,EAAc,KAAE4E,EAAc,KAErC,GAAI5E,EAAiB,GAAK4E,EAAiB,EACzC,MAAO,CAAEnB,QAAAA,EAASC,YAAae,EAAeb,YAAac,GAK7D,GAFAD,EAvagB,SAAC7G,EAAUC,EAAYC,EAAUI,EAAOH,GAC1D,MAAc,MAAVG,EAEiB,MAAfL,GAAmC,MAAbC,GAIa,MAAnCC,EAASH,GAAUC,GAKN,MAAVK,EAEY,MAAfL,GAAmC,MAAbC,GAIa,MAAnCC,EAASH,GAAUC,QANpB,CAWP,CAgZoB6F,CAAY9F,EAAUC,EAAYC,EAAUI,EAAOqE,KAAKxE,UACxE2G,EAhQgB,SAACxG,EAAOJ,GAG1B,OAAmB,MAAbA,GAAiC,MAAbA,KAEZ,MAAVI,GAA8B,MAAbJ,GAEP,MAAVI,GAA8B,MAAbJ,EAGvB,CAsPoB8F,CAAY1F,EAAOJ,GACrB,MAAVI,EAAe,CAEjB,GAAuB,IAAnB0G,GAAuC,MAAf/G,EAC1B,MAAO,CAAE4F,QAAAA,EAASC,YAAae,EAAeb,YAAac,GAG7D,KAAMnG,SAAST,GAAYS,SAASV,IAClC,MAAO,CAAE4F,QAAAA,EAASC,YAAae,EAAeb,YAAac,GAE7D,GAAI1E,IAAmB4E,EACrB,OAAIH,GACFlC,KAAKO,kBAAkB,IACe,KAAtCP,KAAKxE,SAASH,GAAUE,IACxBF,IAAa2E,KAAKO,kBAAkB,IACpCP,KAAKO,kBAAoB,EAAC,EAAO,IAE1B,CAAEW,QADTA,GAAU,EACQC,YAAae,EAAeb,YAAac,IAGJ,MAArDxF,EAAcqD,KAAKxE,SAASH,GAAUE,IAEjC,CAAE2F,QADTA,GAAU,EACQC,YAAae,EAAeb,YAAac,GAGpD,CAAEjB,QAAAA,EAASC,YAAae,EAAeb,YAAac,GAK/D,GAA2B,KAFNvF,EAAiBtB,EAAYC,EAAUH,EAAY4E,KAAKxE,UAAUG,MAGrF,MAAO,CAAEuF,QAAAA,EAASC,YAAae,EAAeb,YAAac,EAE/D,MACK,GAAc,MAAVxG,EAAe,CAEtB,GAAuB,IAAnB0G,GAAuC,MAAf/G,EAC1B,MAAO,CAAE4F,QAAAA,EAASC,YAAae,EAAeb,YAAac,GAG7D,KAAMnG,SAAST,GAAYS,SAASV,IAClC,MAAO,CAAE4F,QAAAA,EAASC,YAAae,EAAeb,YAAac,GAE7D,GAAI1E,IAAmB4E,EACrB,OAAIH,GACFlC,KAAKQ,kBAAkB,IACe,KAAtCR,KAAKxE,SAASH,GAAUE,IACxBF,IAAa2E,KAAKQ,kBAAkB,IACpCR,KAAKQ,kBAAoB,EAAC,EAAO,IAE1B,CAAEU,QADTA,GAAU,EACQC,YAAae,EAAeb,YAAac,IAGJ,MAArDxF,EAAcqD,KAAKxE,SAASH,GAAUE,IAEjC,CAAE2F,QADTA,GAAU,EACQC,YAAae,EAAeb,YAAac,GAGpD,CAAEjB,QAAAA,EAASC,YAAae,EAAeb,YAAac,GAK/D,GAA2B,KAFNvF,EAAiBtB,EAAYC,EAAUH,EAAY4E,KAAKxE,UAAUG,MAGrF,MAAO,CAAEuF,QAAAA,EAASC,YAAae,EAAeb,YAAac,EAE/D,CAcA,OAbuB,IAAnBE,EACY,MAAV1G,EACFqE,KAAKQ,kBAAoB,EAAC,EAAMpF,GAEf,MAAVO,IACPqE,KAAKO,kBAAoB,EAAC,EAAMnF,KAIlC4E,KAAKO,kBAAoB,EAAC,EAAO,IACjCP,KAAKQ,kBAAoB,EAAC,EAAO,KAG5B,CAAEU,QADTA,GAAU,EACQC,YAAae,EAAeb,YAAac,EAC7D,GACA,gCAIA,SAAmB/D,EAAQC,EAAM1C,GAE/B,IAAMsG,EAAmB5E,EAAqBe,EAAQC,GACtD,GAAI4D,EAAiB/D,SAAS,MAE5B,OADAW,QAAQuD,IAAI,yBACL,EAGT,cAAqDH,EAAgB,GAA9D7G,EAAU,KAAEE,EAAU,KAAED,EAAQ,KAAEE,EAAQ,KACjD,EAAyCiC,EAA0BpC,EAAYE,EAAYD,EAAUE,GAAS,eAAvGkC,EAAc,KAAE4E,EAAc,KAErC,OAA0B,IAAnB5E,GAA2C,IAAnB4E,GACT,IAAnB5E,GAA2C,IAAnB4E,IAQvB1G,IAHmBgB,EAAcqD,KAAKxE,SAASH,GAAUE,GAQ/D,GACA,+BAIA,SAAkB6C,EAAQC,EAAM1C,GAO9B,IAAM2G,EAAuBtC,KAAKyB,iBAAiBrD,EAAQC,EAAM1C,GAC3D4G,EAAmBvC,KAAK0B,mBAAmBtD,EAAQC,EAAM1C,GAC/D,SAAK2G,IAAyBC,EAKhC,GACA,8BAIA,SAAiBnE,EAAQC,EAAM1C,GAC7B,IAAIuF,GAAU,EAERe,EAAmB5E,EAAqBe,EAAQC,GAEtD,UAAqD4D,EAAgB,GAA9D7G,EAAU,KAAEE,EAAU,KAAED,EAAQ,KAAEE,EAAQ,KACjD,EAAyCiC,EAA0BpC,EAAYE,EAAYD,EAAUE,GAAS,eAAvGkC,EAAc,KAAE4E,EAAc,KAE/BG,EAnhBO,SAACpE,EAAQC,EAAM1C,EAAOH,EAAUiF,EAAwBC,EAAyBC,EAAwBC,GACxH,GAAc,MAAVjF,EAAe,CACjB,GAAe,OAAXyC,GACS,OAATC,GAA0B,OAATA,GAA0B,OAATA,GAA0B,OAATA,GAC5B,MAAvB7C,EAAY,EAAE,IAAuC,MAAvBA,EAAY,EAAE,GAC9C,OAAO,EAGT,GAAa,OAAT6C,GAA0B,OAATA,EAAe,CAClC,IAAKoC,EACH,OAAO,EAGT,GAA2B,KAAvBjF,EAAY,EAAE,IAAsC,KAAvBA,EAAY,EAAE,GAC7C,OAAO,EAGT,IAAMiH,EAAc5C,EAAQ,KAAM,IAAKrE,GACjCkH,EAAc7C,EAAQ,KAAM,IAAKrE,GACvC,OAAIiH,IAAeC,CAIrB,CAEA,GAAa,OAATrE,GAA0B,OAATA,EAAe,CAClC,IAAKqC,EACH,OAAO,EAGT,GAA2B,KAAvBlF,EAAY,EAAE,IAAsC,KAAvBA,EAAY,EAAE,GAC7C,OAAO,EAGT,IAAMmH,EAAc9C,EAAQ,KAAM,IAAKrE,GACjCoH,EAAc/C,EAAQ,KAAM,IAAKrE,GACvC,OAAImH,IAAeC,CAIrB,CACF,MACK,GAAc,MAAVjH,EAAe,CACtB,GAAe,OAAXyC,GACS,OAATC,GAA0B,OAATA,GAA0B,OAATA,GAA0B,OAATA,GAC5B,MAAvB7C,EAAY,EAAE,IAAuC,MAAvBA,EAAY,EAAE,GAC9C,OAAO,EAGT,GAAa,OAAT6C,GAA0B,OAATA,EAAe,CAClC,IAAKsC,EACH,OAAO,EAGT,GAA2B,KAAvBnF,EAAY,EAAE,IAAsC,KAAvBA,EAAY,EAAE,GAC7C,OAAO,EAGT,IAAMqH,EAAchD,EAAQ,KAAM,IAAKrE,GACjCsH,EAAcjD,EAAQ,KAAM,IAAKrE,GACvC,OAAIqH,IAAeC,CAIrB,CAEA,GAAa,OAATzE,GAA0B,OAATA,EAAe,CAClC,IAAKuC,EACH,OAAO,EAGT,GAA2B,KAAvBpF,EAAY,EAAE,IAAsC,KAAvBA,EAAY,EAAE,GAC7C,OAAO,EAGT,IAAMuH,EAAclD,EAAQ,KAAM,IAAKrE,GACjCwH,EAAcnD,EAAQ,KAAM,IAAKrE,GACvC,OAAIuH,IAAeC,CAIrB,CACF,CACF,CAgcuB5B,CAAShD,EAAQC,EAAM1C,EAAOqE,KAAKxE,SAAUwE,KAAKS,uBAAwBT,KAAKU,wBAAyBV,KAAKW,uBAAwBX,KAAKY,yBAE7J,OAAIyB,EAAiB,EACZ,CAAEnB,QAAAA,EAASE,SAAUoB,GAG1B/E,EAAiB,EACf+E,EAEK,CAAEtB,QADTA,GAAU,EACQE,SAAUoB,GAEvB,CAAEtB,QAAAA,EAASE,SAAUoB,IAO9BtB,EAAUlB,KAAKwB,kBAAkBpD,EAAQC,EAAM1C,KAI3CkE,EAAQxB,EAAM1C,EAAOqE,KAAKxE,UAErB,CAAE0F,QADTA,GAAU,EACQE,SAAUoB,GAJrB,CAAEtB,QAAAA,EAASE,SAAUoB,EAQhC,GACA,gCAIA,SAAmBpE,EAAQC,EAAM1C,GAE/B,IAAMsG,EAAmB5E,EAAqBe,EAAQC,GACtD,GAAI4D,EAAiB/D,SAAS,MAE5B,OADAW,QAAQuD,IAAI,yBACL,EAGT,cAAqDH,EAAgB,GAA9D7G,EAAU,KAAEE,EAAU,KAAED,EAAQ,KAAEE,EAAQ,KACjD,EAAyCiC,EAA0BpC,EAAYE,EAAYD,EAAUE,GAAS,eAE9G,GAFqB,OAAgB,KAGnC,OAAO,EAGT,IAAM0D,EAAqB9D,EAAsBC,EAAYC,EAAUC,EAAYC,EAAUyE,KAAKxE,UAGlG,OAAIG,IAAUsD,EAAmBtD,QAIA,KAA7BsD,EAAmBtD,OACrBsD,EAAmBtD,QAAUA,GAC7BsD,EAAmBxD,SAAW4C,EAKlC,GACA,8BAIA,SAAiBD,EAAQC,EAAM1C,GAE7B,IAAMsG,EAAmB5E,EAAqBe,EAAQC,GACtD,GAAI4D,EAAiB/D,SAAS,MAE5B,OADAW,QAAQuD,IAAI,yBACL,EAGT,cAAqDH,EAAgB,GAA9D7G,EAAU,KAAEE,EAAU,KAAED,EAAQ,KAAEE,EAAQ,KAGjD,GAAMH,IAAeC,GAAYC,IAAeC,EAC9C,OAAO,EAGT,GAAID,IAAeC,EAAU,CAE3B,IAAM0D,EAAqBjC,EAAiB5B,EAAYC,EAAUC,EAAY0E,KAAKxE,UAGnF,GAAIG,IAAUsD,EAAmBtD,MAC/B,OAAO,EAGT,GAAiC,KAA7BsD,EAAmBtD,OACrBsD,EAAmBtD,QAAUA,GAC7BsD,EAAmBxD,SAAW4C,EAC9B,OAAO,CAEX,MAEK,GAAIjD,IAAeC,EAAU,CAEhC,IAAM4D,EAAqBrC,EAAiBtB,EAAYC,EAAUH,EAAY4E,KAAKxE,UAGnF,GAAIG,IAAUsD,EAAmBtD,MAC/B,OAAO,EAGT,GAAiC,KAA7BsD,EAAmBtD,OACrBsD,EAAmBtD,QAAUA,GAC7BsD,EAAmBxD,SAAW4C,EAC9B,OAAO,CAEX,CAYA,MATe,OAAXD,IACF4B,KAAKU,yBAA0B,GAClB,OAAXtC,IACF4B,KAAKS,wBAAyB,GACjB,OAAXrC,IACF4B,KAAKY,yBAA0B,GAClB,OAAXxC,IACF4B,KAAKW,wBAAyB,IAEzB,CACT,KAAC,EA9dY,GAqeTsC,EAAY,SAACvH,GACjBwH,YAAW,WACTxH,EAAMyH,UAAUC,IAAI,WAAY,YAClC,GAAG,EACL,EAKMC,EAAU,SAAC3H,GACfA,EAAMyH,UAAUG,OAAO,WAAY,YACrC,EAOMC,EAAY,SAAC9H,EAAQ+H,EAAWC,GAEpC,IAAMC,EAAoBF,EAAUG,cAAc,aAE5CxG,EAAeuG,EAAkBE,cAAcC,GAC/CC,EAAarI,EAAOoI,GACpBnI,EAAQgI,EAAkBG,GAEhC,EAAwDJ,EAAUM,aAAa5G,EAAc2G,EAAYpI,GAAjGwF,EAAO,EAAPA,QAASC,EAAW,EAAXA,YAAaC,EAAQ,EAARA,SAAUC,EAAW,EAAXA,YACxC,GAAIH,EAAS,CAGX,GAAIC,EAAa,CACf,IAAM6C,EAlsBe,SAACvI,EAAQC,EAAOuI,GACzC,GAA6B,MAAzBtH,EAAcjB,GAAgB,CAChC,IAAMwI,EAAsBzI,EAAO,IAAMO,SAASP,EAAO,IAAM,GAAGiB,WAElE,OAD0BuH,EAAaN,cAAc,IAAD,OAAKO,GAE3D,CACK,GAA6B,MAAzBvH,EAAcjB,GAAgB,CACrC,IAAMwI,EAAsBzI,EAAO,IAAMO,SAASP,EAAO,IAAM,GAAGiB,WAElE,OAD0BuH,EAAaN,cAAc,IAAD,OAAKO,GAE3D,CACF,CAurB8BC,CAAmBL,EAAYpI,EAAO8H,GAI9D,OAHAQ,EAAgBI,UAAY,GAC5B3I,EAAO4I,YAAYX,QACnBA,EAAkBP,UAAUG,OAAO,WAErC,CAGA,GAAIlC,IAAuB,MAAV1F,GAA2B,MAAVA,GAAgB,CAChD,MAvmBqB,SAACA,EAAO2C,EAAM4F,GACvC,IAAIK,EACAC,EACAC,EACAC,EAmCJ,MAlCc,MAAV/I,GACF4I,EAAcL,EAAaN,cAAc,OAC5B,OAATtF,GAA0B,OAATA,GAGnBkG,EAAYN,EAAaN,cAAc,OACvCa,EAAcP,EAAaN,cAAc,OACzCc,EAAYR,EAAaN,cAAc,QAEvB,OAATtF,GAA0B,OAATA,IAGxBkG,EAAYN,EAAaN,cAAc,OACvCa,EAAcP,EAAaN,cAAc,OACzCc,EAAYR,EAAaN,cAAc,SAGxB,MAAVjI,IACP4I,EAAcL,EAAaN,cAAc,OAC5B,OAATtF,GAA0B,OAATA,GAGnBkG,EAAYN,EAAaN,cAAc,OACvCa,EAAcP,EAAaN,cAAc,OACzCc,EAAYR,EAAaN,cAAc,QAEvB,OAATtF,GAA0B,OAATA,IAGxBkG,EAAYN,EAAaN,cAAc,OACvCa,EAAcP,EAAaN,cAAc,OACzCc,EAAYR,EAAaN,cAAc,SAGpC,CAACW,EAAaC,EAAWC,EAAaC,EAC/C,CA+jB+DC,CAAmBhJ,EAAOoI,EAAYN,GAAU,eAAlGc,EAAW,KAAEC,EAAS,KAAEC,EAAW,KAAEC,EAAS,KACrDH,EAAYF,UAAY,GACxBG,EAAUF,YAAYX,GACtB,IAAMiB,EAAOH,EAAYI,kBAIzB,OAHAJ,EAAYJ,UAAY,GACxBK,EAAUJ,YAAYM,QACtBjB,EAAkBP,UAAUG,OAAO,WAErC,CACA,GAAIjC,EAAa,CAEfoC,EAAU5C,aAAc,EAExB6C,EAAkBJ,SAClB,IAOIuB,EACAC,EAREC,EAAgBjB,EAAW,GAC3BkB,EAAuBvJ,EAAOmI,cAKhCqB,EAA6B,GAGnB,MAAVvJ,IACFuJ,GAA8BjJ,SAAS8H,EAAW,IAAM,GAAGpH,WAC3DmI,EAAyBrB,EAAUG,cAAc,IAAD,OAAKG,EAAW,GAAKmB,IACrEH,EAA8BD,EAAuBjB,eAIvD,IAAMsB,EA1kB2B,SAACjI,GAEtC,IAAMkI,EAAqB,4GAAH,OAC+CC,EAAAA,EAAAA,EAAa,sFACdA,EAAAA,EAAAA,EAAa,wFACXA,EAAAA,EAAAA,EAAa,wFACbA,EAAAA,EAAAA,EAAa,kBAE/EC,EAAqB,4GAAH,OAC+CD,EAAAA,EAAAA,EAAa,uFACbA,EAAAA,EAAAA,EAAa,qFACfA,EAAAA,EAAAA,EAAa,sFACZA,EAAAA,EAAAA,EAAa,kBAI7EE,EAAUC,SAASC,cAAc,OACvC,MAAa,MAATvI,GACFqI,EAAQlB,UAAYe,EACbG,EAAQV,mBAEJ,MAAT3H,GACFqI,EAAQlB,UAAYiB,EACbC,EAAQV,wBAFjB,CAIF,CAijBmBa,CAA+BV,GA8B5C,MA7BU,MAAVrJ,EACIsJ,EAAqBU,aAAaR,EAAMzJ,GACxCqJ,EAA4BY,aAAaR,EAAML,QAEnDK,EAAKS,iBAAiB,SAAS,SAAC5K,GAG9B,IAAMiG,EAAmBjG,EAAE6K,OAC3B5E,EAAiBmC,UAAUG,OAAO,mBAClCtC,EAAiB6E,aAAa,YAAa,QAE3C7E,EAAiB2E,iBAAiB,aAAa,WAC7C1C,EAAUjC,EACZ,IACAA,EAAiB2E,iBAAiB,WAAW,WAC3CtC,EAAQrC,EACV,IAGAvF,EAAO2I,UAAY,GACnB3I,EAAO4I,YAAYrD,GACT,MAAVtF,EACIsJ,EAAqBU,aAAajK,EAAQyJ,GAC1CJ,EAA4BY,aAAab,EAAwBK,GAErEzB,EAAUqC,YAAY9E,EAAiB6C,IAEvCJ,EAAU5C,aAAc,CAC1B,GAEF,CAIA,OAHApF,EAAO2I,UAAY,GACnB3I,EAAO4I,YAAYX,QACnBA,EAAkBP,UAAUG,OAAO,WAErC,CACMI,EAAkBE,cAAcC,KAAOpI,EAAOoI,IAClDH,EAAkBP,UAAUG,OAAO,WAEvC,EAwBMyC,EAAa,WACjB,WAAYC,IAAS,gBACnBC,EAAAA,EAAAA,GAAiBjG,KAAMgG,GAEvBhG,KAAKyD,UAAY,IAAI1D,EACrBC,KAAKkG,MAAQ,UACblG,KAAKmG,KAAO,SACd,CAwCC,OAvCD,wCACA,WAAmB,WAEjBnG,KAAKoG,uBAAuBhC,WAAYiC,EAAAA,EAAAA,GAAmBrG,KAAKkG,MAAOlG,KAAKmG,KAAM,+CAElF,IAAMG,EAAStG,KAAKoG,uBAAuBG,iBAAiB,UACtDC,EAAUxG,KAAKoG,uBAAuBG,iBAAiB,WAE7DD,EAAOG,SAAQ,SAAC/K,GACdA,EAAMiK,iBAAiB,aAAa,WAClC1C,EAAUvH,EACZ,IACAA,EAAMiK,iBAAiB,WAAW,WAChCtC,EAAQ3H,EACV,IACAA,EAAMiK,iBAAiB,SAAS,YA3CjB,SAACjK,EAAOgL,EAAcjD,GAEzC,GAAI/H,EAAMyH,UAAUwD,SAAS,YAC3BjL,EAAMyH,UAAUG,OAAO,gBADzB,CAMA,IAAMsD,EAAwBF,EAAa/C,cAAc,aACzD,GAA8B,OAA1BiD,EAMJlL,EAAMyH,UAAUC,IAAI,gBANpB,CACE,IAAMyD,EAAeD,EAAsBhD,cAC3CL,EAAUsD,EAAcH,EAAcjD,EAExC,CARA,CAWF,CA4BQqD,CAAapL,EAAO,EAAK0K,uBAAwB,EAAK3C,UACxD,GACF,IAEA+C,EAAQC,SAAQ,SAAChL,GAEfA,EAAOkK,iBAAiB,YAAY,SAAC5K,GACnCA,EAAEgM,gBACJ,IACAtL,EAAOkK,iBAAiB,QAAQ,SAAC5K,GAC/BA,EAAEgM,iBACFxD,EAAU9H,EAAQ,EAAK2K,uBAAwB,EAAK3C,UACtD,IACAhI,EAAOkK,iBAAiB,SAAS,WAEX,OADA,EAAKS,uBAAuBzC,cAAc,cAG9DJ,EAAU9H,EAAQ,EAAK2K,uBAAwB,EAAK3C,UACtD,GACF,GACF,GAAC,oBACD,WAAS,WACP,OAAQvI,EAAAA,EAAAA,GAAE,MAAO,CAAE8L,IAAK,SAACC,GAAE,OAAM,EAAKb,uBAAyBa,CAAE,EAAGpD,GAAI,4BAC1E,KAAC,EA/CgB,GAiDnBkC,EAAcmB,MAnDW,gzB,wGCt6CrBC,E,UACJ,SAAWA,GACTA,EAAqB,UAAI,IACzBA,EAAqB,UAAI,IACzBA,EAAqB,UAAI,IACzBA,EAAqB,UAAI,IACzBA,EAAuB,YAAI,IAC3BA,EAAuB,YAAI,IAC3BA,EAAuB,YAAI,IAC3BA,EAAuB,YAAI,IAC3BA,EAAsB,WAAI,IAC1BA,EAAsB,WAAI,IAC1BA,EAAqB,UAAI,IACzBA,EAAqB,UAAI,GAC1B,CAbD,CAaGA,IAAcA,EAAY,CAAC,IAK9B,IAAM/B,EAAc,CAClB,EAAK,qGACL,EAAK,qGACL,EAAK,qGACL,EAAK,qGACL,EAAK,qGACL,EAAK,qGACL,EAAK,qGACL,EAAK,qGACL,EAAK,qGACL,EAAK,qGACL,EAAK,qGACL,EAAK,sGAODgC,EAAgB,SAACC,EAAM1L,EAAOlB,EAAYwC,EAAMJ,GACpD,OAAQwK,GACN,KAAKF,EAAUG,UACb,MAAO,YAAP,OAAmB7M,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,+EAAqEyJ,EAAYmC,EAAC,WAC/K,KAAKJ,EAAUK,UACb,MAAO,YAAP,OAAmB/M,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,+EAAqEyJ,EAAYqC,EAAC,WAC/K,KAAKN,EAAUO,UACb,MAAO,YAAP,OAAmBjN,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,+EAAqEyJ,EAAYuC,EAAC,WAC/K,KAAKR,EAAUS,UACb,MAAO,YAAP,OAAmBnN,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,+EAAqEyJ,EAAYyC,EAAC,WAC/K,KAAKV,EAAUW,YACb,MAAO,YAAP,OAAmBrN,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,iFAAuEyJ,EAAY2C,EAAC,WACjL,KAAKZ,EAAUa,YACb,MAAO,YAAP,OAAmBvN,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,iFAAuEyJ,EAAY6C,EAAC,WACjL,KAAKd,EAAUe,YACb,MAAO,YAAP,OAAmBzN,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,iFAAuEyJ,EAAY+C,EAAC,WACjL,KAAKhB,EAAUiB,YACb,MAAO,YAAP,OAAmB3N,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,iFAAuEyJ,EAAYxK,EAAC,WACjL,KAAKuM,EAAUkB,WACb,MAAO,YAAP,OAAmB5N,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,gFAAsEyJ,EAAYkD,EAAC,WAChL,KAAKnB,EAAUoB,WACb,MAAO,YAAP,OAAmB9N,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,gFAAsEyJ,EAAYoD,EAAC,WAChL,KAAKrB,EAAUsB,UACb,MAAO,YAAP,OAAmBhO,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,+EAAqEyJ,EAAYsD,EAAC,WAC/K,KAAKvB,EAAUwB,UACb,MAAO,YAAP,OAAmBlO,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,+EAAqEyJ,EAAYwD,EAAC,WAC/K,QACE,MAAO,GAEb,EAQM3I,EAAgB,WAMpB,IAN6E,IAAxD4I,EAAM,UAAH,6CAAG,8CACrBC,EAAOD,EAAIE,MAAM,KAEjBC,EAAQC,OAAOC,OAAO,CAAC,EAAGxO,EAAAA,GAC5BgB,EAAQ,GAEHuB,EAAO,EAAGA,EAAOxC,EAAAA,EAAAA,OAAmBwC,IAC3C,IAAK,IAAIJ,EAAO,EAAGA,EAAOpC,EAAAA,EAAAA,OAAmBoC,IAAQ,CACnDnB,EAAQoN,EAAK7L,GAAMJ,GAGnB,IAAIsM,EAAgB1O,EAAAA,EAAWwC,GAAMJ,GACjCuM,EAAcD,EAAc,GAC5BE,EAAcF,EAAc,GAEhC,GAAqB,kBAAVzN,GAAsBA,EAAM4N,MAAM,YAC3CN,EAAMI,GAAaC,GAAe3N,OAE/B,GAA+B,kBAApBM,SAASN,GAGvB,IAAK,IAAI6N,EAAU,EAAGA,EAAUvN,SAASN,GAAQ6N,IAC/C1M,GAGN,CAEF,OAAOmM,CACT,EAUM3C,EAAqB,SAACmD,EAAkBC,EAAiBZ,GAY7D,IAVA,IAAMC,EAAOD,EAAIE,MAAM,KAEjBW,EAAa,CAACF,EAAkBC,GAElCE,EAAoB,EAEpBhO,EAAQ,GAERiO,EAAO,GAEF3M,EAAO,EAAGA,EAAOxC,EAAAA,EAAAA,OAAmBwC,IAAQ,CAEnD2M,GAAQ,oBAER,IAAK,IAAI/M,EAAO,EAAGA,EAAOpC,EAAAA,EAAAA,OAAmBoC,IAAQ,CAEnD,IAAIpB,EAASqN,EAAK7L,GAAMJ,GAIxB,GAFAlB,EAAQ+N,EAAWC,GAEG,kBAAXlO,GAAuBA,EAAO6N,MAAM,YAE7CM,GAAQxC,EAAc3L,EAAQE,EAAOlB,EAAAA,EAAYwC,EAAMJ,GAEvD8M,GAAqBA,EAAoB,GAAK,OAE3C,GAAgC,kBAArB3N,SAASP,GAIvB,IAAK,IAAImN,EAAI,EAAGA,EAAI5M,SAASP,GAASmN,IACpCgB,GAAQ,YAAJ,OAAgBnP,EAAAA,EAAWwC,GAAMJ,GAAK,qDAA6ClB,EAAK,YAE5FA,EAAQ+N,EADRC,GAAqBA,EAAoB,GAAK,GAE9C9M,GAGN,CAEA8M,GAAqBA,EAAoB,GAAK,EAE9CC,GAAQ,QACV,CACA,OAAOA,CACT,C","sources":["../node_modules/@arnab7/cheesejs/dist/esm/BoardTypes-d86232b4.js","../node_modules/@arnab7/cheesejs/dist/esm/analysis-board.entry.js","../node_modules/@arnab7/cheesejs/dist/esm/chessboard-456a9829.js"],"sourcesContent":["/**\n * BoardArray is a 2D representation of a Chess board.\n * Each row correspondes to the ranks of a Chess board\n * and each column to the files. Each square's uniqie address\n * on the Chess board can be found with `BoardArray[rank][file]\n */\nconst BoardArray = [\n  ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8'],\n  ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7'],\n  ['a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6'],\n  ['a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5'],\n  ['a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4'],\n  ['a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3'],\n  ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2'],\n  ['a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'],\n];\n/**\n * Object representation of a (currently empty) Chess board\n */\nconst BoardMap = {\n  a: {\n    '1': '',\n    '2': '',\n    '3': '',\n    '4': '',\n    '5': '',\n    '6': '',\n    '7': '',\n    '8': '',\n  },\n  b: {\n    '1': '',\n    '2': '',\n    '3': '',\n    '4': '',\n    '5': '',\n    '6': '',\n    '7': '',\n    '8': '',\n  },\n  c: {\n    '1': '',\n    '2': '',\n    '3': '',\n    '4': '',\n    '5': '',\n    '6': '',\n    '7': '',\n    '8': '',\n  },\n  d: {\n    '1': '',\n    '2': '',\n    '3': '',\n    '4': '',\n    '5': '',\n    '6': '',\n    '7': '',\n    '8': '',\n  },\n  e: {\n    '1': '',\n    '2': '',\n    '3': '',\n    '4': '',\n    '5': '',\n    '6': '',\n    '7': '',\n    '8': '',\n  },\n  f: {\n    '1': '',\n    '2': '',\n    '3': '',\n    '4': '',\n    '5': '',\n    '6': '',\n    '7': '',\n    '8': '',\n  },\n  g: {\n    '1': '',\n    '2': '',\n    '3': '',\n    '4': '',\n    '5': '',\n    '6': '',\n    '7': '',\n    '8': '',\n  },\n  h: {\n    '1': '',\n    '2': '',\n    '3': '',\n    '4': '',\n    '5': '',\n    '6': '',\n    '7': '',\n    '8': '',\n  },\n};\n\nexport { BoardMap as B, BoardArray as a };\n","import { r as registerInstance, h } from './index-bf3a8cd4.js';\nimport { p as pieceImages, f as fenToBoardMap, g as generateChessBoard } from './chessboard-456a9829.js';\nimport './BoardTypes-d86232b4.js';\n\n/**\n * Validator method that checks if another piece is on the way when the\n * given piece is moving diagonally.\n * Then the method returns the data of the obstructing piece\n * and its square. This method can be used for a piece that moves diagonally\n * like the Queen, Bishop, King and the Pawn (while capturing)\n */\nconst checkThroughDiagonals = (originFile, destFile, originRank, destRank, boardMap) => {\n  // Initialize the return values that will hold the data for the piece and\n  // its square\n  let square = ``;\n  let piece = ``;\n  let color = ``;\n  // If the destination is same as the origin, return the origin\n  if (originFile === destFile && originRank === destRank) {\n    return { square: originFile + originRank, piece, color };\n  }\n  // Convert the files to unicode and the ranks to numbers\n  let originFileUnicode = originFile.charCodeAt(0);\n  let destFileUnicode = destFile.charCodeAt(0);\n  let originRankNum = parseInt(originRank);\n  let destRankNum = parseInt(destRank);\n  // The origin square will not be checked so add or subtract 1\n  // from the starting file and rank to look from the next or the previous square\n  let nextFileUnicode = originFileUnicode + 1;\n  let prevFileUnicode = originFileUnicode - 1;\n  let nextRankNum = originRankNum + 1;\n  let prevRankNum = originRankNum - 1;\n  // Set the values for the max and min files and ranks\n  const maxFileUnicode = 'h'.charCodeAt(0);\n  const minFileUnicode = 'a'.charCodeAt(0);\n  const maxRankNum = 8;\n  const minRankNum = 1;\n  // If the piece is going right and up, eg: e5 to h8\n  if (destFileUnicode > originFileUnicode && destRankNum > originRankNum) {\n    while ((nextFileUnicode <= destFileUnicode &&\n      nextFileUnicode <= maxFileUnicode) ||\n      (nextRankNum <= destRankNum && nextRankNum <= maxRankNum)) {\n      // Get the square and piece data\n      square = String.fromCharCode(nextFileUnicode) + nextRankNum.toString();\n      piece = boardMap[square[0]][square[1]];\n      color = getPieceColor(piece);\n      if (piece === '') {\n        // If the squre is empty, go to the next square (if any)\n        nextFileUnicode++;\n        nextRankNum++;\n      }\n      else {\n        // This means there is a piece on the way\n        break;\n      }\n    }\n  }\n  // If the piece is going right and down, eg: e5 to h1\n  else if (destFileUnicode > originFileUnicode && destRankNum < originRankNum) {\n    while ((nextFileUnicode <= destFileUnicode &&\n      nextFileUnicode <= maxFileUnicode) ||\n      (prevRankNum >= destRankNum && prevRankNum >= minRankNum)) {\n      // Get the square and piece data\n      square = String.fromCharCode(nextFileUnicode) + prevRankNum.toString();\n      piece = boardMap[square[0]][square[1]];\n      color = getPieceColor(piece);\n      if (piece === '') {\n        // If the squre is empty, go to the next square (if any)\n        nextFileUnicode++;\n        prevRankNum--;\n      }\n      else {\n        // This means there is a piece on the way\n        break;\n      }\n    }\n  }\n  // If the piece is going left and up, eg: e5 to a1\n  else if (destFileUnicode < originFileUnicode && destRankNum > originRankNum) {\n    while ((prevFileUnicode >= destFileUnicode &&\n      prevFileUnicode >= minFileUnicode) ||\n      (nextRankNum <= destRankNum && nextRankNum <= maxRankNum)) {\n      // Get the square and piece data\n      square = String.fromCharCode(prevFileUnicode) + nextRankNum.toString();\n      piece = boardMap[square[0]][square[1]];\n      color = getPieceColor(piece);\n      if (piece === '') {\n        // If the squre is empty, go to the next square (if any)\n        prevFileUnicode--;\n        nextRankNum++;\n      }\n      else {\n        // This means there is a piece on the way\n        break;\n      }\n    }\n  }\n  // If the piece is going left and down, eg: e5 to h1\n  else if (destFileUnicode < originFileUnicode && destRankNum < originRankNum) {\n    while ((prevFileUnicode >= destFileUnicode &&\n      prevFileUnicode >= minFileUnicode) ||\n      (prevRankNum >= destRankNum && prevRankNum >= minRankNum)) {\n      // Get the square and piece data\n      square = String.fromCharCode(prevFileUnicode) + prevRankNum.toString();\n      piece = boardMap[square[0]][square[1]];\n      color = getPieceColor(piece);\n      if (piece === '') {\n        // If the squre is empty, go to the next square (if any)\n        prevFileUnicode--;\n        prevRankNum--;\n      }\n      else {\n        // This means there is a piece on the way\n        break;\n      }\n    }\n  }\n  return { square, piece, color };\n};\n/**\n * Function that returns diagonal edge square information according to the given\n * direction\n */\nconst getDiagonalEdge = (square, direction) => {\n  const [file, rank] = getFileAndRank(square);\n  let fileUnicode = file.charCodeAt(0);\n  let rankNum = parseInt(rank);\n  const maxFileUnicode = 'h'.charCodeAt(0);\n  const minFileUnicode = 'a'.charCodeAt(0);\n  const maxRank = 8;\n  const minRank = 1;\n  if (direction === 'right-up') {\n    while (fileUnicode < maxFileUnicode && rankNum < maxRank) {\n      fileUnicode++;\n      rankNum++;\n    }\n  }\n  else if (direction === 'right-down') {\n    while (fileUnicode < maxFileUnicode && rankNum > minRank) {\n      fileUnicode++;\n      rankNum--;\n    }\n  }\n  else if (direction === 'left-up') {\n    while (fileUnicode > minFileUnicode && rankNum < maxRank) {\n      fileUnicode--;\n      rankNum++;\n    }\n  }\n  else if (direction === 'left-down') {\n    while (fileUnicode > minFileUnicode && rankNum > minRank) {\n      fileUnicode--;\n      rankNum--;\n    }\n  }\n  return [String.fromCharCode(fileUnicode), rankNum.toFixed()];\n};\n/**\n * Validator method that checks if another piece is on the way when the\n * given piece is moving through one file and multiple ranks (moving\n * vertically). Then the method returns the data of the obstructing piece\n * and its square. This method can be used for a piece that moves vertically\n * like the Queen, Rook, King and the Pawn\n */\nconst checkThroughFile = (originRank, destRank, file, boardMap) => {\n  // Initialize the return values that will hold the data for the piece and\n  // its square\n  let square = ``;\n  let piece = ``;\n  let color = ``;\n  // If the destination is same as the origin, return the origin\n  if (originRank === destRank) {\n    return { square: file + originRank, piece, color };\n  }\n  // Convert the rank characters to numbers\n  const originRankNum = parseInt(originRank);\n  const destRankNum = parseInt(destRank);\n  // The origin square will not be checked so add or subtract 1\n  // from the starting rank to look from the next or previous rank respectively\n  let nextRank = originRankNum + 1;\n  let prevRank = originRankNum - 1;\n  // If the piece is moving up (eg: a1 to a8)\n  if (originRankNum < destRankNum) {\n    for (nextRank; nextRank <= destRankNum; nextRank++) {\n      // Get the square and piece data\n      square = file + nextRank.toString();\n      piece = boardMap[square[0]][square[1]];\n      color = getPieceColor(piece);\n      if (piece === '') {\n        // If there is no piece on the way\n        continue;\n      }\n      else {\n        // This means there is a piece on the way\n        break;\n      }\n    }\n  }\n  // If the piece is moving down (eg: a8 to a1)\n  else {\n    for (prevRank; prevRank >= destRankNum; prevRank--) {\n      // Get the square and piece data\n      square = file + prevRank.toString();\n      piece = boardMap[square[0]][square[1]];\n      color = getPieceColor(piece);\n      if (piece === '') {\n        // If there is no piece on the way\n        continue;\n      }\n      else {\n        // This means there is a piece on the way\n        break;\n      }\n    }\n  }\n  return { square, piece, color };\n};\n/**\n * Validator method that checks if another piece is on the way when the\n * given piece is moving through one rank and multiple files (moving\n * horizontally). Then the method returns the data of the obstructing piece\n * and its square. This method can be used for a piece that moves horizontally\n * like the Queen, Rook and the King\n */\nconst checkThroughRank = (originFile, destFile, rank, boardMap) => {\n  // Initialize the return values that will hold the data for the piece and\n  // its square\n  let square = ``;\n  let piece = ``;\n  let color = ``;\n  // If the destination is same as the origin, return the origin\n  if (originFile === destFile && boardMap) {\n    return { square: originFile + rank, piece, color };\n  }\n  // Get the unicode value of the files\n  let originFileUnicode = originFile.charCodeAt(0);\n  let destFileUnicode = destFile.charCodeAt(0);\n  // The origin square will not be checked so add or subtract 1\n  // from the starting file to look from the next or previous file respectively\n  let nextFileUnicode = originFileUnicode + 1;\n  let prevFileUnicode = originFileUnicode - 1;\n  // If the piece is moving from left to right (eg: a1 to h1)\n  if (originFileUnicode < destFileUnicode) {\n    for (nextFileUnicode; nextFileUnicode <= destFileUnicode; nextFileUnicode++) {\n      // Get the square and piece data\n      square = String.fromCharCode(nextFileUnicode) + rank;\n      piece = boardMap[square[0]][square[1]];\n      color = getPieceColor(piece);\n      if (piece === '') {\n        // If there is no piece on the way\n        continue;\n      }\n      else {\n        // This means there is a piece on the way\n        break;\n      }\n    }\n  }\n  // If the piece is moving from right to left (eg: h1 to a1)\n  else {\n    for (prevFileUnicode; prevFileUnicode >= destFileUnicode; prevFileUnicode--) {\n      // Get the square and piece data\n      square = String.fromCharCode(prevFileUnicode) + rank;\n      piece = boardMap[square[0]][square[1]];\n      color = getPieceColor(piece);\n      if (piece === '') {\n        // If there is no piece on the way\n        continue;\n      }\n      else {\n        // This means there is a piece on the way\n        break;\n      }\n    }\n  }\n  return { square, piece, color };\n};\n/**\n * Function that takes two squares and checks if they are adjacent\n * to one another, either vertically, horizontally or diagonally\n */\nconst isAdjacent = (originSquare, objectedSquare) => {\n  // Get the info of the origin and objected square\n  const [originFile, originRank, objectedFile, objectedRank] = getOriginAndDestInfo(originSquare, objectedSquare);\n  const [fileDifference, rankDifference] = getFileAndRankDifferences(originFile, originRank, objectedFile, objectedRank);\n  // Check if theyare diagonally adjaent\n  if (fileDifference === rankDifference && fileDifference === 1) {\n    return true;\n  }\n  // If they are on the same file\n  if (originFile === objectedFile) {\n    if (Math.abs(parseInt(originRank) - parseInt(objectedRank)) === 1) {\n      return true;\n    }\n  }\n  // If they are on the same rank\n  else if (originRank === objectedRank) {\n    if (Math.abs(originFile.charCodeAt(0) - objectedFile.charCodeAt(0)) === 1) {\n      return true;\n    }\n  }\n  // If none of the checks returned true that means the squares are not adjacent\n  return false;\n};\n/**\n * Function that takes information about the King, and an array\n * of enemy pieces and checks if those pieces can give a check to\n * the King\n */\nconst evaluateCheck = (objectedPiece, ownPieceColor, objectedPieceColor, enemyWhitePieces, enemyBlackPieces) => {\n  // This means there is an own piece before enemy one, so not check\n  if (objectedPieceColor === ownPieceColor) {\n    return false;\n  }\n  // Check if the objected piece is in the list of pieces that\n  // can give the King a check\n  if (ownPieceColor === 'w' && enemyBlackPieces.includes(objectedPiece)) {\n    return true;\n  }\n  else if (ownPieceColor === 'b' &&\n    enemyWhitePieces.includes(objectedPiece)) {\n    return true;\n  }\n  // If none of the checks returned true, then there is no check\n  return false;\n};\n/**\n * Method that takes the moving piece, its origin and destination\n * square and updates the board accordingly\n */\nconst updateBoardMap = (piece, origin, dest, boardMap) => {\n  const [originFile, originRank, destFile, destRank] = getOriginAndDestInfo(origin, dest);\n  let boardMapToUpdate = JSON.parse(JSON.stringify(boardMap));\n  // Empty and original square and place the piece on the destination square\n  boardMapToUpdate[originFile][originRank] = '';\n  boardMapToUpdate[destFile][destRank] = piece;\n  return boardMapToUpdate;\n};\nconst getPieceColor = (piece) => {\n  if (piece === '')\n    return '';\n  // If the piece symbol is a lowercase character (like 'b') then\n  // it is a black piece, else it is a white piece\n  return piece.toLowerCase() === piece ? `b` : `w`;\n};\n/**\n * Method that retrieves the file names and rank numbers from the original\n * and destination squares and returnes them in an array\n */\nconst getOriginAndDestInfo = (origin, dest) => {\n  const [originFile, originRank] = getFileAndRank(origin);\n  const [destFile, destRank] = getFileAndRank(dest);\n  return [originFile, originRank, destFile, destRank];\n};\n/**\n * Method that returns the differnces between the origin file and thes\n * destination file and the same for the ranks in an array\n */\nconst getFileAndRankDifferences = (originFile, originRank, destFile, destRank) => {\n  const fileDifference = Math.abs(originFile.charCodeAt(0) - destFile.charCodeAt(0));\n  const rankDifference = Math.abs(parseInt(originRank) - parseInt(destRank));\n  return [fileDifference, rankDifference];\n};\nconst getFileAndRank = (square) => {\n  // If the square is malformatted\n  if (square.length !== 2 && typeof parseInt(square[1]) !== 'number') {\n    console.error('Invalid square given');\n    return [null, null];\n  }\n  return [square[0], square[1]];\n};\n\n/**\n * Function that returns if the King is safe from checks after a move is\n * played, If it returns false, then the move cannot be played as then the\n * King can be captured\n */\nconst isSafe = (piece, origin, dest, whiteKingsPosition, blackKingsPosition, boardMap) => {\n  const updatedBoardMap = updateBoardMap(piece, origin, dest, boardMap);\n  const color = getPieceColor(piece);\n  // After the move has been played and the temporary board has been\n  // updated, see if the new position takes the King into check and return\n  // the opposite of it (as the opposite of being checked is being safe)\n  if (color === 'w') {\n    return !isCheck(whiteKingsPosition, 'w', updatedBoardMap);\n  }\n  if (color === 'b') {\n    return !isCheck(blackKingsPosition, 'b', updatedBoardMap);\n  }\n};\n/**\n * Function that checks in a file according to the given direction if there are\n * any piece on the way which can give the King a check\n * @param direction must be either \"up\" or \"down\"\n */\nconst checkVertically = (file, rank, color, direction, boardMap) => {\n  let isCheck = false;\n  let objectedSquareInfo = {\n    square: '',\n    piece: '',\n    color: '',\n  };\n  // Check if any piece is on the way\n  if (direction === 'up') {\n    objectedSquareInfo = checkThroughFile(rank, '8', file, boardMap);\n  }\n  else if (direction === 'down') {\n    objectedSquareInfo = checkThroughFile(rank, '1', file, boardMap);\n    if (color === 'w' && objectedSquareInfo.piece === 'K') {\n      objectedSquareInfo = checkThroughFile((parseInt(rank) - 2).toString(), '1', file, boardMap);\n    }\n    if (color === 'b' && objectedSquareInfo.piece === 'k') {\n      objectedSquareInfo = checkThroughFile((parseInt(rank) - 2).toString(), '1', file, boardMap);\n    }\n  }\n  // Check if the objected piece is on the adjaent square\n  if (isAdjacent(file + rank, objectedSquareInfo.square)) {\n    // Check if any enemy King, Queen or Rook is on the way\n    isCheck = evaluateCheck(objectedSquareInfo.piece, color, objectedSquareInfo.color, ['Q', 'R', 'K'], ['q', 'r', 'k']);\n    if (isCheck) {\n      return true;\n    }\n  }\n  // Check if any enemy Queen or Rook is on the way across squares\n  isCheck = evaluateCheck(objectedSquareInfo.piece, color, objectedSquareInfo.color, ['Q', 'R'], ['q', 'r']);\n  if (isCheck) {\n    return true;\n  }\n  // If none of the checks returned true, then there is no check\n  return false;\n};\n/**\n * Function that checks in a rank according to the given direction if there are\n * any piece on the way which can give the King a check\n * @param direction must be either \"right\" or \"left\"\n */\nconst checkHorizontally = (file, rank, color, direction, boardMap) => {\n  let isCheck = false;\n  let objectedSquareInfo = {\n    square: '',\n    piece: '',\n    color: '',\n  };\n  // Check if any piece is on the way\n  if (direction === 'left') {\n    objectedSquareInfo = checkThroughRank(file, 'a', rank, boardMap);\n  }\n  else if (direction === 'right') {\n    objectedSquareInfo = checkThroughRank(file, 'h', rank, boardMap);\n  }\n  // Check if the objected piece is on the adjaent square\n  if (isAdjacent(file + rank, objectedSquareInfo.square)) {\n    // Check if any enemy King, Queen or Rook is on the way\n    isCheck = evaluateCheck(objectedSquareInfo.piece, color, objectedSquareInfo.color, ['Q', 'R', 'K'], ['q', 'r', 'k']);\n    if (isCheck) {\n      return true;\n    }\n  }\n  // Check if any enemy Queen or Rook is on the way across squares\n  isCheck = evaluateCheck(objectedSquareInfo.piece, color, objectedSquareInfo.color, ['Q', 'R'], ['q', 'r']);\n  if (isCheck) {\n    return true;\n  }\n  // If none of the checks returned true, then there is no check\n  return false;\n};\n/**\n *Function that retrives a piece from the boardMap object with the given\n file and rank information as unicode value and integers respectively\n */\nconst pieceAt = (fileUnicode, rankNum, boardMap) => {\n  // If the file or the rank is out of bounds of the board, return an empty string\n  if (rankNum > 8 ||\n    rankNum < 1 ||\n    fileUnicode > 'h'.charCodeAt(0) ||\n    fileUnicode < 'a'.charCodeAt(0)) {\n    return '';\n  }\n  return boardMap[String.fromCharCode(fileUnicode)][rankNum.toString()];\n};\n/**\n * Fynction that checks if an enemy Knight can give a check to the King\n * from any direction\n */\nconst isCheckFromKnight = (file, rank, color, boardMap) => {\n  const fileUnicode = file.charCodeAt(0);\n  const rankNum = parseInt(rank);\n  // Check if any Knight can check the King from any direction\n  if (color === 'w') {\n    if (pieceAt(fileUnicode + 1, rankNum + 2, boardMap) === 'n')\n      return true;\n    if (pieceAt(fileUnicode - 1, rankNum + 2, boardMap) === 'n')\n      return true;\n    if (pieceAt(fileUnicode + 1, rankNum - 2, boardMap) === 'n')\n      return true;\n    if (pieceAt(fileUnicode - 1, rankNum - 2, boardMap) === 'n')\n      return true;\n    if (pieceAt(fileUnicode + 2, rankNum + 1, boardMap) === 'n')\n      return true;\n    if (pieceAt(fileUnicode - 2, rankNum + 1, boardMap) === 'n')\n      return true;\n    if (pieceAt(fileUnicode + 2, rankNum - 1, boardMap) === 'n')\n      return true;\n    if (pieceAt(fileUnicode - 2, rankNum - 1, boardMap) === 'n')\n      return true;\n    return false;\n  }\n  if (color === 'b') {\n    if (pieceAt(fileUnicode + 1, rankNum + 2, boardMap) === 'N')\n      return true;\n    if (pieceAt(fileUnicode - 1, rankNum + 2, boardMap) === 'N')\n      return true;\n    if (pieceAt(fileUnicode + 1, rankNum - 2, boardMap) === 'N')\n      return true;\n    if (pieceAt(fileUnicode - 1, rankNum - 2, boardMap) === 'N')\n      return true;\n    if (pieceAt(fileUnicode + 2, rankNum + 1, boardMap) === 'N')\n      return true;\n    if (pieceAt(fileUnicode - 2, rankNum + 1, boardMap) === 'N')\n      return true;\n    if (pieceAt(fileUnicode + 2, rankNum - 1, boardMap) === 'N')\n      return true;\n    if (pieceAt(fileUnicode - 2, rankNum - 1, boardMap) === 'N')\n      return true;\n    return false;\n  }\n};\n/**\n * Funtion that checks if the King is in check by an enemy pawn.\n * @param direction must be either \"right-up\", \"left-up\", \"right-down\"\n * or \"left-down\"\n */\nconst isCheckFromPawn = (color, pawn, direction) => {\n  // If a black pawn is digonally above the white King, it is a check\n  if (color === 'w' &&\n    pawn === 'p' &&\n    (direction === 'right-up' || direction === 'left-up')) {\n    return true;\n  }\n  // If a white pawn is digonally below the black King, it is a check\n  else if (color === 'b' &&\n    pawn === 'P' &&\n    (direction === 'right-down' || direction === 'left-down')) {\n    return true;\n  }\n  // If none of the checks returned true, then there is no check\n  return false;\n};\n/**\n * Function that checks diagonally according to the given direction if there are\n * any piece on the way which can give the King a check\n * @param direction must be either \"right-up\", \"left-up\", \"right-down\"\n * or \"left-down\"\n */\nconst checkDiagonally = (file, rank, color, direction, boardMap) => {\n  // Get the diagonal edge for a given direction\n  let [diagonalEdgeFile, diagonalEdgeRank] = getDiagonalEdge(file + rank, direction);\n  let isCheck = false;\n  let objectedSquareInfo = {\n    square: '',\n    piece: '',\n    color: '',\n  };\n  // Check if an enemy piece is on the way through the diagonal\n  objectedSquareInfo = checkThroughDiagonals(file, diagonalEdgeFile, rank, diagonalEdgeRank, boardMap);\n  // Check if the objected piece is on the adjaent square\n  if (isAdjacent(file + rank, objectedSquareInfo.square)) {\n    // Check if there is any check from a Pawn\n    if (isCheckFromPawn(color, objectedSquareInfo.piece, direction)) {\n      return true;\n    }\n    // Check if any enemy King, Queen or Bishop is on the way\n    isCheck = evaluateCheck(objectedSquareInfo.piece, color, objectedSquareInfo.color, ['Q', 'B', 'K'], ['q', 'b', 'k']);\n    if (isCheck) {\n      return true;\n    }\n  }\n  // Check if any enemy Queen or Bishop is on the way across squares\n  isCheck = evaluateCheck(objectedSquareInfo.piece, color, objectedSquareInfo.color, ['Q', 'B'], ['q', 'b']);\n  if (isCheck) {\n    return true;\n  }\n  // If none of the checks returned true, then there is no check\n  return false;\n};\n/**\n * Function that checks if the King is in check in any given square\n */\nconst isCheck = (square, color, boardMap) => {\n  // Get the file and rank of the square\n  const [file, rank] = getFileAndRank(square);\n  // Check vertically for an enemy King, Rook or Queen\n  if (checkVertically(file, rank, color, 'up', boardMap))\n    return true;\n  if (checkVertically(file, rank, color, 'down', boardMap))\n    return true;\n  // Check horizontally for an enemy King, Rook or Queen\n  if (checkHorizontally(file, rank, color, 'right', boardMap))\n    return true;\n  if (checkHorizontally(file, rank, color, 'left', boardMap))\n    return true;\n  // Check diagonally for an enemy Pawm, King, Bishop or Queen\n  if (checkDiagonally(file, rank, color, 'right-up', boardMap))\n    return true;\n  if (checkDiagonally(file, rank, color, 'right-down', boardMap))\n    return true;\n  if (checkDiagonally(file, rank, color, 'left-up', boardMap))\n    return true;\n  if (checkDiagonally(file, rank, color, 'left-down', boardMap))\n    return true;\n  // Check for an enemy Knight\n  if (isCheckFromKnight(file, rank, color, boardMap))\n    return true;\n  // If none of the checks returned true, that means the King is not in check\n  return false;\n};\n\n/**\n * Function to check if a Pawn move is en passant.This does not heck the legality\n * of the move (like if the Pawn can en passant or not)\n */\nconst isEnPassant = (destFile, originRank, destRank, color, boardMap) => {\n  if (color === 'w') {\n    // White Pawns can only en passant from the 5th rank to the 6th rank\n    if (originRank !== '5' || destRank !== '6') {\n      return false;\n    }\n    // There must a black Pawn adjacent to the white Pawns origin square\n    if (boardMap[destFile][originRank] !== 'p') {\n      return false;\n    }\n    return true;\n  }\n  else if (color === 'b') {\n    // Black Pawns can only en passant from the 4th rank to the 3rd rank\n    if (originRank !== '4' || destRank !== '3') {\n      return false;\n    }\n    // There must a white Pawn adjacent to the black Pawns origin square\n    if (boardMap[destFile][originRank] !== 'P') {\n      return false;\n    }\n    return true;\n  }\n};\nconst getEnPassantSquare = (square, piece, documentHTML) => {\n  if (getPieceColor(piece) === 'w') {\n    const enPassantedSquareId = square[0] + (parseInt(square[1]) - 1).toString();\n    const enPassantedSquare = documentHTML.querySelector(`#${enPassantedSquareId}`);\n    return enPassantedSquare;\n  }\n  else if (getPieceColor(piece) === 'b') {\n    const enPassantedSquareId = square[0] + (parseInt(square[1]) + 1).toString();\n    const enPassantedSquare = documentHTML.querySelector(`#${enPassantedSquareId}`);\n    return enPassantedSquare;\n  }\n};\nconst isCastle = (origin, dest, color, boardMap, canWhiteCastleKingSide, canWhiteCastleQueenSide, canBlackCastleKingSide, canBlackCastleQueenSide) => {\n  if (color === 'w') {\n    if (origin !== 'e1' ||\n      !(dest === 'g1' || dest === 'h1' || dest === 'c1' || dest === 'a1') ||\n      !(boardMap['h']['1'] === 'R' || boardMap['a']['1'] === 'R')) {\n      return false;\n    }\n    // Validate Kingside castle\n    if (dest === 'g1' || dest === 'h1') {\n      if (!canWhiteCastleKingSide) {\n        return false;\n      }\n      // The castlingsquares must be empty\n      if (boardMap['f']['1'] !== '' || boardMap['g']['1'] !== '') {\n        return false;\n      }\n      // <ale sure that the castling squares are not checked by amy piece\n      const isF1Checked = isCheck('f1', 'w', boardMap);\n      const isG1Checked = isCheck('g1', 'w', boardMap);\n      if (isF1Checked || isG1Checked) {\n        return false;\n      }\n      return true;\n    }\n    // Validate Queenside castle\n    if (dest === 'c1' || dest === 'a1') {\n      if (!canWhiteCastleQueenSide) {\n        return false;\n      }\n      // The castlingsquares must be empty\n      if (boardMap['d']['1'] !== '' || boardMap['c']['1'] !== '') {\n        return false;\n      }\n      // <ale sure that the castling squares are not checked by amy piece\n      const isD1Checked = isCheck('d1', 'w', boardMap);\n      const isC1Checked = isCheck('c1', 'w', boardMap);\n      if (isD1Checked || isC1Checked) {\n        return false;\n      }\n      return true;\n    }\n  }\n  else if (color === 'b') {\n    if (origin !== 'e8' ||\n      !(dest === 'g8' || dest === 'h8' || dest === 'c8' || dest === 'a8') ||\n      !(boardMap['h']['8'] === 'r' || boardMap['a']['8'] === 'r')) {\n      return false;\n    }\n    // Validate Kingside castle\n    if (dest === 'g8' || dest === 'h8') {\n      if (!canBlackCastleKingSide) {\n        return false;\n      }\n      // The castlingsquares must be empty\n      if (boardMap['f']['8'] !== '' || boardMap['g']['8'] !== '') {\n        return false;\n      }\n      // <ale sure that the castling squares are not checked by amy piece\n      const isF8Checked = isCheck('f8', 'b', boardMap);\n      const isG8Checked = isCheck('g8', 'b', boardMap);\n      if (isF8Checked || isG8Checked) {\n        return false;\n      }\n      return true;\n    }\n    // Validate Queenside castle\n    if (dest === 'c8' || dest === 'a8') {\n      if (!canBlackCastleQueenSide) {\n        return false;\n      }\n      // The castlingsquares must be empty\n      if (boardMap['d']['8'] !== '' || boardMap['c']['8'] !== '') {\n        return false;\n      }\n      // <ale sure that the castling squares are not checked by amy piece\n      const isD8Checked = isCheck('d8', 'b', boardMap);\n      const isC8Checked = isCheck('c8', 'b', boardMap);\n      if (isD8Checked || isC8Checked) {\n        return false;\n      }\n      return true;\n    }\n  }\n};\n/**\n * Function that returns the origin and desination squares of the King and the Rook castling\n * as Element\n */\nconst getCastlingSquares = (piece, dest, documentHTML) => {\n  let KingsOrigin;\n  let KingsDest;\n  let RooksOrigin;\n  let RooksDest;\n  if (piece === 'K') {\n    KingsOrigin = documentHTML.querySelector('#e1');\n    if (dest === 'g1' || dest === 'h1') {\n      // if the white King is castling Kingside, its destination square should be g1\n      // and the Rook should go to f1\n      KingsDest = documentHTML.querySelector('#g1');\n      RooksOrigin = documentHTML.querySelector('#h1');\n      RooksDest = documentHTML.querySelector('#f1');\n    }\n    else if (dest === 'c1' || dest === 'a1') {\n      // if the white King is castling Queenside, its destination square should be c1\n      // and the Rook should go to d1\n      KingsDest = documentHTML.querySelector('#c1');\n      RooksOrigin = documentHTML.querySelector('#a1');\n      RooksDest = documentHTML.querySelector('#d1');\n    }\n  }\n  else if (piece === 'k') {\n    KingsOrigin = documentHTML.querySelector('#e8');\n    if (dest === 'g8' || dest === 'h8') {\n      // if the black King is castling Kingside, its destination square should be g8\n      // and the Rook should go to f8\n      KingsDest = documentHTML.querySelector('#g8');\n      RooksOrigin = documentHTML.querySelector('#h8');\n      RooksDest = documentHTML.querySelector('#f8');\n    }\n    else if (dest === 'c8' || dest === 'a8') {\n      // if the black King is castling Queenside, its destination square should be c8\n      // and the Rook should go to d8\n      KingsDest = documentHTML.querySelector('#c8');\n      RooksOrigin = documentHTML.querySelector('#a8');\n      RooksDest = documentHTML.querySelector('#d8');\n    }\n  }\n  return [KingsOrigin, KingsDest, RooksOrigin, RooksDest];\n};\n/**\n * Function that returns if Pawn move is a Pawn promotion\n */\nconst isPromotion = (color, destRank) => {\n  // Pawns can only promote on the 8th and the 1st square (for white and black\n  // respectively)\n  if (!(destRank === '8' || destRank === '1'))\n    return false;\n  if (color === 'w' && destRank === '8')\n    return true;\n  if (color === 'b' && destRank === '1')\n    return true;\n  return false;\n};\n/**\n * Function that returns an HTML element for the list for the pieces a Pawn can promote to\n * according to its color\n */\nconst createPawnPromotionHtmlElement = (rank) => {\n  // Create HTML string for both the colors\n  const whitePromotionHtml = `<div class='promotion-list'>\n       <img id=\"Q\" alt='white queen' class=\"piece promoting-piece\" src=${pieceImages.Q}>\n       <img id=\"R\" alt='white rook' class=\"piece promoting-piece\" src=${pieceImages.R}>\n       <img id=\"B\" alt='white bishop' class=\"piece promoting-piece\" src=${pieceImages.B}>\n       <img id=\"N\" alt='white knight' class=\"piece promoting-piece\" src=${pieceImages.N}>\n     </div>`;\n  const blackPromotionHtml = `<div class='promotion-list'>\n      <img id=\"n\" alt='black knight' class=\"piece promoting-piece\" src=${pieceImages.n}>\n      <img id=\"b\" alt='black bishop' class=\"piece promoting-piece\" src=${pieceImages.b}>\n      <img id=\"r\" alt='black rook' class=\"piece promoting-piece\" src=${pieceImages.r}>\n      <img id=\"q\" alt='black queen' class=\"piece promoting-piece\" src=${pieceImages.q}>\n     </div>`;\n  // Add the HTML strings above to a Wrapper element\n  // and extract it to return it as an individual element\n  const Wrapper = document.createElement('div');\n  if (rank === '8') {\n    Wrapper.innerHTML = whitePromotionHtml;\n    return Wrapper.firstElementChild;\n  }\n  if (rank === '1') {\n    Wrapper.innerHTML = blackPromotionHtml;\n    return Wrapper.firstElementChild;\n  }\n};\n\n/**\n * The main move validator class that contains the methods for validating\n * all the moves and contains all the states of the game\n */\nclass Validator {\n  constructor() {\n    // Declarations of properties that will hold various states of the game\n    this.boardMap = fenToBoardMap();\n    this.whitesTurn = true;\n    this.movingPiece = '';\n    this.movingPiecesOrigin = '';\n    this.movingPiecesDest = '';\n    this.movingPiecesColor = '';\n    this.canWhiteEnPassant = [false, ''];\n    this.canBlackEnPassant = [false, ''];\n    this.canWhiteCastleKingSide = true;\n    this.canWhiteCastleQueenSide = true;\n    this.canBlackCastleKingSide = true;\n    this.canBlackCastleQueenSide = true;\n    this.IsPromoting = false;\n    this.whiteKingsPosition = 'e1';\n    this.blackKingsPosition = 'e8';\n  }\n  /**\n   * Method to run after a Pawn promotion that updates the game's states\n   */\n  PromotePawn(pieceToPromoteTo) {\n    // Update the board map\n    const updatedBoardMap = updateBoardMap(pieceToPromoteTo, this.movingPiecesOrigin, this.movingPiecesDest, this.boardMap);\n    this.boardMap = JSON.parse(JSON.stringify(updatedBoardMap));\n    // Toggle the color's turn\n    this.whitesTurn = !this.whitesTurn;\n  }\n  /**\n   * Method to run after each move that updates the game's states\n   */\n  newMove() {\n    // Update the board map\n    const updatedBoardMap = updateBoardMap(this.movingPiece, this.movingPiecesOrigin, this.movingPiecesDest, this.boardMap);\n    this.boardMap = JSON.parse(JSON.stringify(updatedBoardMap));\n    // Toggle the color's turn\n    this.whitesTurn = !this.whitesTurn;\n  }\n  /**\n   Validator method that takes in a piece and runs the corresponding validator\n   function for that piece\n  */\n  ValidateMove(origin, dest, piece) {\n    // Initialize the return values\n    let isValid = false;\n    let isEnPassant = false;\n    let isCastle = false;\n    let isPromotion = false;\n    if (origin === dest) {\n      return { isValid, isEnPassant, isCastle, isPromotion };\n    }\n    // Temporarily change the movingPieceColor to the moving piece's color\n    // If the move is invalid, thecolor will be changed back to the previous one\n    // tempHoldColor holds the previous color value\n    let tempColor = this.movingPiecesColor;\n    this.movingPiecesColor = getPieceColor(piece);\n    // Check if the moving piece matches the appropriate color's turn\n    if (this.whitesTurn && this.movingPiecesColor !== 'w') {\n      return { isValid, isEnPassant, isCastle, isPromotion };\n    }\n    else if (!this.whitesTurn && this.movingPiecesColor !== 'b') {\n      return { isValid, isEnPassant, isCastle, isPromotion };\n    }\n    // Check if a Pawn is promoting while this move is played\n    if (this.IsPromoting) {\n      return { isValid, isEnPassant, isCastle, isPromotion };\n    }\n    // Run the appropriate validator function for the moving piece\n    switch (piece) {\n      case `K`:\n        ({ isValid, isCastle } = this.validateKingMove(origin, dest, `w`));\n        break;\n      case 'k':\n        ({ isValid, isCastle } = this.validateKingMove(origin, dest, `b`));\n        break;\n      case `Q`:\n        isValid = this.validateQueenMove(origin, dest, `w`);\n        break;\n      case 'q':\n        isValid = this.validateQueenMove(origin, dest, `b`);\n        break;\n      case `R`:\n        isValid = this.validateRookMove(origin, dest, `w`);\n        break;\n      case `r`:\n        isValid = this.validateRookMove(origin, dest, `b`);\n        break;\n      case `B`:\n        isValid = this.validateBishopMove(origin, dest, `w`);\n        break;\n      case 'b':\n        isValid = this.validateBishopMove(origin, dest, `b`);\n        break;\n      case 'N':\n        isValid = this.validateKnightMove(origin, dest, `w`);\n        break;\n      case 'n':\n        isValid = this.validateKnightMove(origin, dest, `b`);\n        break;\n      case 'P':\n        ({ isValid, isEnPassant, isPromotion } = this.validatePawnMove(origin, dest, `w`));\n        break;\n      case 'p':\n        ({ isValid, isEnPassant, isPromotion } = this.validatePawnMove(origin, dest, `b`));\n        break;\n    }\n    if (isValid) {\n      // Take away the King's castling rights after it moves and updates its position\n      if (piece === 'K') {\n        this.whiteKingsPosition = dest;\n        this.canWhiteCastleKingSide = false;\n        this.canWhiteCastleQueenSide = false;\n      }\n      else if (piece === 'k') {\n        this.blackKingsPosition = dest;\n        this.canBlackCastleKingSide = false;\n        this.canBlackCastleQueenSide = false;\n      }\n      // Copy of the boardMap to temprarily make the move and update the board\n      const tempBoardMap = JSON.parse(JSON.stringify(this.boardMap));\n      // Check if the King would be safe if the move is played\n      // If the King is not safe, the move is not valid\n      const isKingSafeAfterTheMove = isSafe(piece, origin, dest, this.whiteKingsPosition, this.blackKingsPosition, tempBoardMap);\n      if (!isKingSafeAfterTheMove) {\n        return { isValid: false, isEnPassant, isCastle, isPromotion };\n      }\n      // If the move is a castling move update the board accordingly\n      if (isCastle) {\n        if (piece === 'K') {\n          this.boardMap['e']['1'] = '';\n          if (dest === 'g1' || dest === 'h1') {\n            this.boardMap['g']['1'] = 'K';\n            this.boardMap['f']['1'] = 'R';\n            this.boardMap['h']['1'] = '';\n          }\n          else if (dest === 'c1' || dest === 'a1') {\n            this.boardMap['c']['1'] = 'K';\n            this.boardMap['d']['1'] = 'R';\n            this.boardMap['a']['1'] = '';\n          }\n        }\n        else if (piece === 'k') {\n          this.boardMap['e']['8'] = '';\n          if (dest === 'g8' || dest === 'h8') {\n            this.boardMap['g']['8'] = 'k';\n            this.boardMap['f']['8'] = 'r';\n            this.boardMap['h']['8'] = '';\n          }\n          else if (dest === 'c8' || dest === 'a8') {\n            this.boardMap['c']['8'] = 'k';\n            this.boardMap['d']['8'] = 'r';\n            this.boardMap['a']['8'] = '';\n          }\n        }\n        // Toggle the color's turn\n        this.whitesTurn = !this.whitesTurn;\n        return { isValid, isEnPassant, isCastle, isPromotion };\n      }\n      if (isPromotion) {\n        return { isValid, isEnPassant, isCastle, isPromotion };\n      }\n      if (isEnPassant) {\n        if (piece === 'P') {\n          this.boardMap[dest[0]][(parseInt(dest[1]) - 1).toString()] = '';\n        }\n        else if (piece === 'p') {\n          this.boardMap[dest[0]][(parseInt(dest[1]) + 1).toString()] = '';\n        }\n      }\n      if (!(piece === 'P' || piece === 'p')) {\n        this.canBlackEnPassant = [false, ''];\n        this.canWhiteEnPassant = [false, ''];\n      }\n      // Set the info of the moving piece to the states\n      this.movingPiece = piece;\n      this.movingPiecesOrigin = origin;\n      this.movingPiecesDest = dest;\n      // Call the newMove method to update the game's states\n      this.newMove();\n      return { isValid, isEnPassant, isCastle, isPromotion };\n    }\n    // If none of the checks returned true, that means that the move is invalid\n    // Change the movingPieeColor's value to the previous color\n    this.movingPiecesColor = tempColor;\n    return { isValid, isEnPassant, isCastle, isPromotion };\n  }\n  /**\n   * Validator method for the Pawn that checks if\n   * the square the Pawn is trying to move to is legal\n   */\n  validatePawnMove(origin, dest, color) {\n    // Get the file and rank information and check they are correct\n    const fileAndRankArray = getOriginAndDestInfo(origin, dest);\n    let isValid = false;\n    let isEnPassant$1 = false;\n    let isPromotion$1 = false;\n    if (fileAndRankArray.includes(null)) {\n      console.log('invalid square input');\n      return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n    }\n    // Get the information of the origin and destination squares and their differences\n    const [originFile, originRank, destFile, destRank] = fileAndRankArray;\n    const [fileDifference, rankDifference] = getFileAndRankDifferences(originFile, originRank, destFile, destRank);\n    // A Pawn cammot move diagonally or vertically more than 1 square\n    if (fileDifference > 1 || rankDifference > 2) {\n      return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n    }\n    let objectedPieceColor = '';\n    isEnPassant$1 = isEnPassant(destFile, originRank, destRank, color, this.boardMap);\n    isPromotion$1 = isPromotion(color, destRank);\n    if (color === 'w') {\n      // Pawns can only move 2 squares from their initial position\n      if (rankDifference === 2 && originRank !== '2') {\n        return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n      }\n      // White Pawns can only move up\n      if (!(parseInt(destRank) > parseInt(originRank))) {\n        return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n      }\n      if (fileDifference === rankDifference) {\n        if (isEnPassant$1 &&\n          this.canWhiteEnPassant[0] &&\n          this.boardMap[destFile][destRank] === '' &&\n          destFile === this.canWhiteEnPassant[1]) {\n          this.canWhiteEnPassant = [false, ''];\n          isValid = true;\n          return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n        }\n        // A Pawn can only move diagonally if it is capturing an enemy piece\n        if (getPieceColor(this.boardMap[destFile][destRank]) === 'b') {\n          isValid = true;\n          return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n        }\n        else {\n          return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n        }\n      }\n      objectedPieceColor = checkThroughFile(originRank, destRank, originFile, this.boardMap).color;\n      // Pawns can only move forward if the square is empty\n      if (objectedPieceColor !== '') {\n        return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n      }\n    }\n    else if (color === 'b') {\n      // Pawns can only move 2 squares from their initial position\n      if (rankDifference === 2 && originRank !== '7') {\n        return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n      }\n      // Black Pawns can only move down\n      if (!(parseInt(destRank) < parseInt(originRank))) {\n        return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n      }\n      if (fileDifference === rankDifference) {\n        if (isEnPassant$1 &&\n          this.canBlackEnPassant[0] &&\n          this.boardMap[destFile][destRank] === '' &&\n          destFile === this.canBlackEnPassant[1]) {\n          this.canBlackEnPassant = [false, ''];\n          isValid = true;\n          return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n        }\n        // A Pawn can only move diagonally if it is capturing an enemy piece\n        if (getPieceColor(this.boardMap[destFile][destRank]) === 'w') {\n          isValid = true;\n          return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n        }\n        else {\n          return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n        }\n      }\n      objectedPieceColor = checkThroughFile(originRank, destRank, originFile, this.boardMap).color;\n      // Pawns can only move forward if the square is empty\n      if (objectedPieceColor !== '') {\n        return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n      }\n    }\n    if (rankDifference === 2) {\n      if (color === 'w') {\n        this.canBlackEnPassant = [true, originFile];\n      }\n      else if (color === 'b') {\n        this.canWhiteEnPassant = [true, originFile];\n      }\n    }\n    else {\n      this.canWhiteEnPassant = [false, ''];\n      this.canBlackEnPassant = [false, ''];\n    }\n    isValid = true;\n    return { isValid, isEnPassant: isEnPassant$1, isPromotion: isPromotion$1 };\n  }\n  /**\n   * Validator method for the Knight that checks if\n   * the square the Knight is trying to move to is legal\n   */\n  validateKnightMove(origin, dest, color) {\n    // Get the file and rank information and check they are correct\n    const fileAndRankArray = getOriginAndDestInfo(origin, dest);\n    if (fileAndRankArray.includes(null)) {\n      console.log('invalid square input');\n      return false;\n    }\n    // Get the information of the origin and destination squares\n    const [originFile, originRank, destFile, destRank] = fileAndRankArray;\n    const [fileDifference, rankDifference] = getFileAndRankDifferences(originFile, originRank, destFile, destRank);\n    // Check that the Knight can only move in an L shape\n    if (!((fileDifference === 1 && rankDifference === 2) ||\n      (fileDifference === 2 && rankDifference === 1))) {\n      return false;\n    }\n    // Check if thereis any piece on the destination square\n    // and get its color\n    const destPieceColor = getPieceColor(this.boardMap[destFile][destRank]);\n    // If the obected piece's color is same as the Knight\n    // then the Knight cannot move /to it\n    if (color === destPieceColor) {\n      return false;\n    }\n    // if none of checks returned false, that means the move is valid\n    return true;\n  }\n  /**\n   * Validator method for the Queen that checks if\n   * the square the Queen is trying to move to is legal\n   */\n  validateQueenMove(origin, dest, color) {\n    /*\n    The Queen is basically a Rook plus a Bishop. So instead of writing\n    a separate validator for the Queen, the same validators for the\n    Rook and the Bishop can be used. If one of them return true then the\n    move is valid,else it is invalid\n     */\n    const IsValidRanksAndFiles = this.validateRookMove(origin, dest, color);\n    const IsValidDiagonals = this.validateBishopMove(origin, dest, color);\n    if (!IsValidRanksAndFiles && !IsValidDiagonals) {\n      return false;\n    }\n    // if none of checks returned false, that means the move is valid\n    return true;\n  }\n  /**\n   * Validator method for the King that checks if\n   * the square the King is trying to move to is legal\n   */\n  validateKingMove(origin, dest, color) {\n    let isValid = false;\n    // Get the file and rank information and check they are correct\n    const fileAndRankArray = getOriginAndDestInfo(origin, dest);\n    // Get the information of the origin and destination squares and their differences\n    const [originFile, originRank, destFile, destRank] = fileAndRankArray;\n    const [fileDifference, rankDifference] = getFileAndRankDifferences(originFile, originRank, destFile, destRank);\n    // Check if the move is a castling move\n    const isCastle$1 = isCastle(origin, dest, color, this.boardMap, this.canWhiteCastleKingSide, this.canWhiteCastleQueenSide, this.canBlackCastleKingSide, this.canBlackCastleQueenSide);\n    // If the move is more than one square then it is an illegal move\n    if (rankDifference > 1) {\n      return { isValid, isCastle: isCastle$1 };\n    }\n    // The King can only move 2 files if it is a castling move\n    if (fileDifference > 1) {\n      if (isCastle$1) {\n        isValid = true;\n        return { isValid, isCastle: isCastle$1 };\n      }\n      return { isValid, isCastle: isCastle$1 };\n    }\n    /*\n    The King moves exactly like the Queen except for only one square.\n    So, after the one square rule is validated, the Queen's validator can be used\n    for the King's move\n     */\n    isValid = this.validateQueenMove(origin, dest, color);\n    if (!isValid) {\n      return { isValid, isCastle: isCastle$1 };\n    }\n    if (isCheck(dest, color, this.boardMap)) {\n      isValid = false;\n      return { isValid, isCastle: isCastle$1 };\n    }\n    // if none of checks returned false, that means the move is valid\n    return { isValid, isCastle: isCastle$1 };\n  }\n  /**\n   * Validator method for the Bishop that checks if\n   * the square the Bishop is trying to move to is legal\n   */\n  validateBishopMove(origin, dest, color) {\n    // Get the file and rank information and check they are correct\n    const fileAndRankArray = getOriginAndDestInfo(origin, dest);\n    if (fileAndRankArray.includes(null)) {\n      console.log('invalid square input');\n      return false;\n    }\n    // Get the information of the origin and destination squares and their differences\n    const [originFile, originRank, destFile, destRank] = fileAndRankArray;\n    const [fileDifference, rankDifference] = getFileAndRankDifferences(originFile, originRank, destFile, destRank);\n    // If the move is not diagonal then it is an illegal move\n    if (fileDifference !== rankDifference) {\n      return false;\n    }\n    // See if there is any piece on the way\n    const objectedSquareInfo = checkThroughDiagonals(originFile, destFile, originRank, destRank, this.boardMap);\n    // If the piece's color is same as the Bishop\n    // then the Bishop cannot move through/to it\n    if (color === objectedSquareInfo.color) {\n      return false;\n    }\n    // This makes sure the pieces cannot jump over the enemy pieces\n    if (objectedSquareInfo.color !== '' &&\n      objectedSquareInfo.color !== color &&\n      objectedSquareInfo.square !== dest) {\n      return false;\n    }\n    // if none of checks returned false, that means the move is valid\n    return true;\n  }\n  /**\n   * Validator method for the Rook that checks if\n   * the square the Rook is trying to move to is legal\n   */\n  validateRookMove(origin, dest, color) {\n    // Get the file and rank information and check they are correct\n    const fileAndRankArray = getOriginAndDestInfo(origin, dest);\n    if (fileAndRankArray.includes(null)) {\n      console.log('invalid square input');\n      return false;\n    }\n    // Get the information of the origin and destination squares\n    const [originFile, originRank, destFile, destRank] = fileAndRankArray;\n    // If the move is neither straight horizontal or vertical\n    // then it is an illegal move\n    if (!(originFile === destFile || originRank === destRank)) {\n      return false;\n    }\n    // If The move is along the files (horizontal, like a1 to h1)\n    if (originRank === destRank) {\n      // See if there is any piece on the way\n      const objectedSquareInfo = checkThroughRank(originFile, destFile, originRank, this.boardMap);\n      // If the piece's color is same as the Rook\n      // then the Rook cannot move through/to it\n      if (color === objectedSquareInfo.color) {\n        return false;\n      }\n      // This makes sure the pieces cannot jump over the enemy pieces\n      if (objectedSquareInfo.color !== '' &&\n        objectedSquareInfo.color !== color &&\n        objectedSquareInfo.square !== dest) {\n        return false;\n      }\n    }\n    // If the move is along ranks (vertically, like a1 to a8)\n    else if (originFile === destFile) {\n      // See if there is any piece on the way\n      const objectedSquareInfo = checkThroughFile(originRank, destRank, originFile, this.boardMap);\n      // If the piece's color is same as the Rook\n      // then the Rook cannot move through/to it\n      if (color === objectedSquareInfo.color) {\n        return false;\n      }\n      // This makes sure the pieces cannot jump over the enemy pieces\n      if (objectedSquareInfo.color !== '' &&\n        objectedSquareInfo.color !== color &&\n        objectedSquareInfo.square !== dest) {\n        return false;\n      }\n    }\n    // If the Rook moves from its original square, take awau the\n    // castling rights of the King according to which Rook moved\n    if (origin === 'a1')\n      this.canWhiteCastleQueenSide = false;\n    if (origin === 'h1')\n      this.canWhiteCastleKingSide = false;\n    if (origin === 'a8')\n      this.canBlackCastleQueenSide = false;\n    if (origin === 'h8')\n      this.canBlackCastleKingSide = false;\n    // if none of checks returned false, that means the move is valid\n    return true;\n  }\n}\n\n/**\n * Event listener function for the 'dragstart' event. This adds the 'dragging'\n * and 'invisible' class to the dragged piece\n */\nconst dragStart = (piece) => {\n  setTimeout(() => {\n    piece.classList.add('dragging', 'invisible');\n  }, 0);\n};\n/**\n * Event listener function for the 'dragend' event. This removes the 'dragging'\n * and 'invisible' class to the dragged piece\n */\nconst dragEnd = (piece) => {\n  piece.classList.remove('dragging', 'invisible');\n};\n/**\n * Event listener function for the 'drop' event. This checks if the move is valid\n * with the provided validator class and drops the piece on the square if it is\n * valid.This also takes care of special moves like 'en passant', 'castling' and\n * 'Pawn promotion'\n */\nconst dropPiece = (square, boardHtml, validator) => {\n  // Get the HTML element being dragged\n  const pieceBeingDragged = boardHtml.querySelector('.dragging');\n  // Get the info for the piece, its origin and destination square\n  const originSquare = pieceBeingDragged.parentElement.id;\n  const destSquare = square.id;\n  const piece = pieceBeingDragged.id;\n  // Validate the move\n  const { isValid, isEnPassant, isCastle, isPromotion } = validator.ValidateMove(originSquare, destSquare, piece);\n  if (isValid) {\n    // Get the square where the opposite Pawn moved 2 squares tp (which can get en passanted)\n    // and remove that Pawn\n    if (isEnPassant) {\n      const enPassantSquare = getEnPassantSquare(destSquare, piece, boardHtml);\n      enPassantSquare.innerHTML = '';\n      square.appendChild(pieceBeingDragged);\n      pieceBeingDragged.classList.remove('dragging');\n      return;\n    }\n    // If the move is a castling move, change the King and the Rook's\n    // positions accordingly\n    if (isCastle && (piece === 'K' || piece === 'k')) {\n      const [KingsOrigin, KingsDest, RooksOrigin, RooksDest] = getCastlingSquares(piece, destSquare, boardHtml);\n      KingsOrigin.innerHTML = '';\n      KingsDest.appendChild(pieceBeingDragged);\n      const Rook = RooksOrigin.firstElementChild;\n      RooksOrigin.innerHTML = '';\n      RooksDest.appendChild(Rook);\n      pieceBeingDragged.classList.remove('dragging');\n      return;\n    }\n    if (isPromotion) {\n      // Toggle the IsPromoting state to true\n      validator.IsPromoting = true;\n      // Delete the pawn from the square it was on before the promotion\n      pieceBeingDragged.remove();\n      const promotionRank = destSquare[1];\n      const promotionRankElement = square.parentElement;\n      // For the black Pawn's promotion, the list will be displayed\n      // starting from 3 squares above so that list ends on the promotion\n      // square. Get the temprary elements and its info if only the\n      // promoting pawn is a black Pawn\n      let temporaryReplaceSquareRank = '';\n      let temporaryReplaceSquare;\n      let temporaryReplaceRankElement;\n      if (piece === 'p') {\n        temporaryReplaceSquareRank = (parseInt(destSquare[1]) + 3).toString();\n        temporaryReplaceSquare = boardHtml.querySelector(`#${destSquare[0] + temporaryReplaceSquareRank}`);\n        temporaryReplaceRankElement = temporaryReplaceSquare.parentElement;\n      }\n      // Get the list of the pieces that cane be promoted to and replace it with\n      // with the appropriate square\n      const list = createPawnPromotionHtmlElement(promotionRank);\n      piece === 'P'\n        ? promotionRankElement.replaceChild(list, square)\n        : temporaryReplaceRankElement.replaceChild(list, temporaryReplaceSquare);\n      // This event listner runs when a piece from the list is clicked\n      list.addEventListener('click', (e) => {\n        // Get the selected piece, remove its promoting class and\n        // add the same attributes as a normal piece\n        const pieceToPromoteTo = e.target;\n        pieceToPromoteTo.classList.remove('promoting-piece');\n        pieceToPromoteTo.setAttribute('draggable', 'true');\n        // Set the same dragging event listeners to the promoted piece as a normal piece\n        pieceToPromoteTo.addEventListener('dragstart', () => {\n          dragStart(pieceToPromoteTo);\n        });\n        pieceToPromoteTo.addEventListener('dragend', () => {\n          dragEnd(pieceToPromoteTo);\n        });\n        // Add the promoted piece to its promoted square and replace the\n        // list element with original square element according to color\n        square.innerHTML = '';\n        square.appendChild(pieceToPromoteTo);\n        piece === 'P'\n          ? promotionRankElement.replaceChild(square, list)\n          : temporaryReplaceRankElement.replaceChild(temporaryReplaceSquare, list);\n        // Update the boardMap with the new promoted piece\n        validator.PromotePawn(pieceToPromoteTo.id);\n        // Toggle the IsPromoting state to false\n        validator.IsPromoting = false;\n      });\n      return;\n    }\n    square.innerHTML = '';\n    square.appendChild(pieceBeingDragged);\n    pieceBeingDragged.classList.remove('dragging');\n    return;\n  }\n  if (!(pieceBeingDragged.parentElement.id === square.id)) {\n    pieceBeingDragged.classList.remove('dragging');\n  }\n};\n/**\n * Event handler to run when a piece is clicked\n */\nconst onPieceClick = (piece, documentHtml, validator) => {\n  // If the piece is already highlighted, unhighlight it  \n  if (piece.classList.contains('dragging')) {\n    piece.classList.remove('dragging');\n    return;\n  }\n  // See if any other piece is highlighted as well, if there is\n  // then try to move to that square (will be invalid for same color piece)\n  const otherHighlightedPiece = documentHtml.querySelector('.dragging');\n  if (otherHighlightedPiece !== null) {\n    const parentSquare = otherHighlightedPiece.parentElement;\n    dropPiece(parentSquare, documentHtml, validator);\n    return;\n  }\n  // Highlight the piece\n  piece.classList.add('dragging');\n};\n\nconst analysisBoardCss = \"#analysis-board-container{position:relative;width:400px;height:400px;border:1px solid black}.row{display:flex;flex-direction:row;width:100%;height:50px}.promotion-list{display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:10;height:210px;width:55px}.square{width:50px;height:50px;border:0.1px black}.list-squares{width:50px;height:50px;border:0.1px black;background-color:lightgray}.piece{display:flex;justify-content:center;align-items:center;touch-action:none;cursor:grab;cursor:move}.promoting-piece{background-color:gray}.piece:active{cursor:grabbing}.dragging{transform:scale(1.2);transition:0.2s ease-in-out}.invisible{display:none}@media (max-width: 550px){#analysis-board-container{width:360px;height:360px}.row{height:45px}.square{width:45px;height:45px}.piece{height:40px}}\";\n\nconst AnalysisBoard = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    // An instance of the Validator class for move validation\n    this.validator = new Validator();\n    this.light = '#E0C35A';\n    this.dark = '#7A6A31';\n  }\n  // This method is called when the component has finished loading\n  componentDidLoad() {\n    // Set the inner HTML of the checkerboard container to the HTML string for the checkered board\n    this.analysisBoardContainer.innerHTML = generateChessBoard(this.light, this.dark, 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR');\n    // Get all the pieces and squares in the chess board\n    const pieces = this.analysisBoardContainer.querySelectorAll('.piece');\n    const squares = this.analysisBoardContainer.querySelectorAll('.square');\n    // Add drag, drop and click event listeners to each piece\n    pieces.forEach((piece) => {\n      piece.addEventListener('dragstart', () => {\n        dragStart(piece);\n      });\n      piece.addEventListener('dragend', () => {\n        dragEnd(piece);\n      });\n      piece.addEventListener('click', () => {\n        onPieceClick(piece, this.analysisBoardContainer, this.validator);\n      });\n    });\n    // Add drag, drop and click event listeners to each square\n    squares.forEach((square) => {\n      // Allow dropping on the square by preventing the default behavior\n      square.addEventListener('dragover', (e) => {\n        e.preventDefault();\n      });\n      square.addEventListener('drop', (e) => {\n        e.preventDefault();\n        dropPiece(square, this.analysisBoardContainer, this.validator);\n      });\n      square.addEventListener('click', () => {\n        const movingPiece = this.analysisBoardContainer.querySelector('.dragging');\n        if (movingPiece === null)\n          return;\n        dropPiece(square, this.analysisBoardContainer, this.validator);\n      });\n    });\n  }\n  render() {\n    return (h(\"div\", { ref: (el) => (this.analysisBoardContainer = el), id: \"analysis-board-container\" }));\n  }\n};\nAnalysisBoard.style = analysisBoardCss;\n\nexport { AnalysisBoard as analysis_board };\n","import { B as BoardMap, a as BoardArray } from './BoardTypes-d86232b4.js';\n\n/**\n * This enum matches with the piece representations of an FEN string.\n * Capital letter for white pieces and small letter for black pieces\n */\nvar PieceType;\n(function (PieceType) {\n  PieceType[\"whitePawn\"] = \"P\";\n  PieceType[\"blackPawn\"] = \"p\";\n  PieceType[\"whiteRook\"] = \"R\";\n  PieceType[\"blackRook\"] = \"r\";\n  PieceType[\"whiteKnight\"] = \"N\";\n  PieceType[\"blackKnight\"] = \"n\";\n  PieceType[\"whiteBishop\"] = \"B\";\n  PieceType[\"blackBishop\"] = \"b\";\n  PieceType[\"whiteQueen\"] = \"Q\";\n  PieceType[\"blackQueen\"] = \"q\";\n  PieceType[\"whiteKing\"] = \"K\";\n  PieceType[\"blackKing\"] = \"k\";\n})(PieceType || (PieceType = {}));\n\n/**\n * Object that holds the svg.png links for all the Chess pieces\n */\nconst pieceImages = {\n  'K': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Chess_klt45.svg/45px-Chess_klt45.svg.png',\n  'k': 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/f0/Chess_kdt45.svg/45px-Chess_kdt45.svg.png',\n  'Q': 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Chess_qlt45.svg/45px-Chess_qlt45.svg.png',\n  'q': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/Chess_qdt45.svg/45px-Chess_qdt45.svg.png',\n  'R': 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Chess_rlt45.svg/45px-Chess_rlt45.svg.png',\n  'r': 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Chess_rdt45.svg/45px-Chess_rdt45.svg.png',\n  'B': 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Chess_blt45.svg/45px-Chess_blt45.svg.png',\n  'b': 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Chess_bdt45.svg/45px-Chess_bdt45.svg.png',\n  'N': 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Chess_nlt45.svg/45px-Chess_nlt45.svg.png',\n  'n': 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Chess_ndt45.svg/45px-Chess_ndt45.svg.png',\n  'P': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/45px-Chess_plt45.svg.png',\n  'p': 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/45px-Chess_pdt45.svg.png'\n};\n\n/**\n * getPieceImage takes a piece type and color and returns the corresponding symbol for the piece,\n * and function then creates an HTML string to add the pieces to the squares\n */\nconst getPieceImage = (type, color, BoardArray, rank, file) => {\n  switch (type) {\n    case PieceType.whitePawn:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"P\" alt='white pawn' class=\"piece\" draggable=\"true\" src=${pieceImages.P}></div>`;\n    case PieceType.blackPawn:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"p\" alt='black pawn' class=\"piece\" draggable=\"true\" src=${pieceImages.p}></div>`;\n    case PieceType.whiteRook:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"R\" alt='white rook' class=\"piece\" draggable=\"true\" src=${pieceImages.R}></div>`;\n    case PieceType.blackRook:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"r\" alt='black rook' class=\"piece\" draggable=\"true\" src=${pieceImages.r}></div>`;\n    case PieceType.whiteKnight:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"N\" alt='white knight' class=\"piece\" draggable=\"true\" src=${pieceImages.N}></div>`;\n    case PieceType.blackKnight:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"n\" alt='black knight' class=\"piece\" draggable=\"true\" src=${pieceImages.n}></div>`;\n    case PieceType.whiteBishop:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"B\" alt='white bishop' class=\"piece\" draggable=\"true\" src=${pieceImages.B}></div>`;\n    case PieceType.blackBishop:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"b\" alt='black bishop' class=\"piece\" draggable=\"true\" src=${pieceImages.b}></div>`;\n    case PieceType.whiteQueen:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"Q\" alt='white queen' class=\"piece\" draggable=\"true\" src=${pieceImages.Q}></div>`;\n    case PieceType.blackQueen:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"q\" alt='black queen' class=\"piece\" draggable=\"true\" src=${pieceImages.q}></div>`;\n    case PieceType.whiteKing:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"K\" alt='white king' class=\"piece\" draggable=\"true\" src=${pieceImages.K}></div>`;\n    case PieceType.blackKing:\n      return `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"><img id=\"k\" alt='black king' class=\"piece\" draggable=\"true\" src=${pieceImages.k}></div>`;\n    default:\n      return '';\n  }\n};\n/**\n * fenToBoardMap takes one optional input\n * @param fen : an FEN string of a vlid Chess position. If no FEN\n * os provided then uses the FEN for the starting position and\n * @returns an object representation of a Chess board and places pieces\n * according to the FEN\n */\nconst fenToBoardMap = (fen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR') => {\n  const rows = fen.split('/');\n  // create a copy of the BoardMap\n  const board = Object.assign({}, BoardMap);\n  let piece = '';\n  // Iterate over the ranks and files of the Chess board array\n  for (let rank = 0; rank < BoardArray.length; rank++) {\n    for (let file = 0; file < BoardArray.length; file++) {\n      piece = rows[rank][file];\n      // Each square is a 2 character string, like 'a1'\n      // The following code will extract the file and rank out of each square\n      let currentSquare = BoardArray[rank][file];\n      let currentFile = currentSquare[0];\n      let currentRank = currentSquare[1];\n      // if the piece is a character, it is a piece\n      if (typeof piece === 'string' && piece.match(/[a-zA-Z]/)) {\n        board[currentFile][currentRank] = piece;\n      }\n      else if (typeof parseInt(piece) === 'number') {\n        // If the piece is a number then it is the number of empty squares\n        // Sp ;oop through the array and increment the file to leave out the empty squares\n        for (let empties = 0; empties < parseInt(piece); empties++) {\n          file++;\n        }\n      }\n    }\n  }\n  return board;\n};\n\n// To learn about FEN stings, visit: https://www.chess.com/terms/fen-chess\n/**\n * generateChessBoard is a function that takes three optional arguments:\n * @param lightSquareColor string representing the color of the light squares on the chess board\n * @param darkSquareColor string representing the color of the dark squares on the chess board\n * @param fen string representing the FEN notation of the current state of the chess board\n * and returns an HTML string representing the chess board with the given colors and piece positions\n */\nconst generateChessBoard = (lightSquareColor, darkSquareColor, fen) => {\n  // split the FEN notation into rows\n  const rows = fen.split('/');\n  // array to store the colors of the squares on the chess board\n  const colorArray = [lightSquareColor, darkSquareColor];\n  // index to keep track of the current color of the square\n  let currentColorIndex = 0;\n  // color of the current square\n  let color = ``;\n  // HTML string to store the HTML representation of the chess board\n  let html = ``;\n  // iterate through each row of the chess board\n  for (let rank = 0; rank < BoardArray.length; rank++) {\n    // add opening div tag for the row to the HTML string\n    html += `<div class=\"row\">`;\n    // iterate through each square in the row\n    for (let file = 0; file < BoardArray.length; file++) {\n      // get the FEN notation for the current square\n      let square = rows[rank][file];\n      // set the color of the square to the current color\n      color = colorArray[currentColorIndex];\n      // if the square is a character, it is a piece\n      if (typeof square === 'string' && square.match(/[a-zA-Z]/)) {\n        // add the HTML returned from the getPieeImage\n        html += getPieceImage(square, color, BoardArray, rank, file);\n        // toggle the current color index to switch the color of the next square\n        currentColorIndex = (currentColorIndex + 1) % 2;\n      }\n      else if (typeof parseInt(square) === 'number') {\n        // if the square is a number, it represents empty squares\n        // if the number is >1, then it means there are that many empty squares\n        // add the number of empty squares to the HTML string\n        for (let k = 0; k < parseInt(square); k++) {\n          html += `<div id=\"${BoardArray[rank][file]}\" class=\"square\" style=\"background-color: ${color}\"></div>`;\n          currentColorIndex = (currentColorIndex + 1) % 2;\n          color = colorArray[currentColorIndex];\n          file++;\n        }\n      }\n    }\n    // toggle the current color index to switch the color of the first square in the next row\n    currentColorIndex = (currentColorIndex + 1) % 2;\n    // add the closing div tag for the rows\n    html += `</div>`;\n  }\n  return html;\n};\n\nexport { fenToBoardMap as f, generateChessBoard as g, pieceImages as p };\n"],"names":["BoardArray","BoardMap","a","b","c","d","e","f","g","h","checkThroughDiagonals","originFile","destFile","originRank","destRank","boardMap","square","piece","color","originFileUnicode","charCodeAt","destFileUnicode","originRankNum","parseInt","destRankNum","nextFileUnicode","prevFileUnicode","nextRankNum","prevRankNum","maxFileUnicode","minFileUnicode","String","fromCharCode","toString","getPieceColor","checkThroughFile","file","nextRank","prevRank","checkThroughRank","rank","isAdjacent","originSquare","objectedSquare","getOriginAndDestInfo","objectedFile","objectedRank","getFileAndRankDifferences","fileDifference","Math","abs","evaluateCheck","objectedPiece","ownPieceColor","objectedPieceColor","enemyWhitePieces","enemyBlackPieces","includes","updateBoardMap","origin","dest","boardMapToUpdate","JSON","parse","stringify","toLowerCase","getFileAndRank","length","console","error","checkVertically","direction","objectedSquareInfo","checkHorizontally","pieceAt","fileUnicode","rankNum","checkDiagonally","toFixed","getDiagonalEdge","diagonalEdgeFile","diagonalEdgeRank","pawn","isCheckFromPawn","isCheck","isCheckFromKnight","Validator","this","fenToBoardMap","whitesTurn","movingPiece","movingPiecesOrigin","movingPiecesDest","movingPiecesColor","canWhiteEnPassant","canBlackEnPassant","canWhiteCastleKingSide","canWhiteCastleQueenSide","canBlackCastleKingSide","canBlackCastleQueenSide","IsPromoting","whiteKingsPosition","blackKingsPosition","pieceToPromoteTo","updatedBoardMap","isValid","isEnPassant","isCastle","isPromotion","tempColor","validateKingMove","validateQueenMove","validateRookMove","validateBishopMove","validateKnightMove","validatePawnMove","tempBoardMap","isKingSafeAfterTheMove","isSafe","newMove","fileAndRankArray","isEnPassant$1","isPromotion$1","log","rankDifference","IsValidRanksAndFiles","IsValidDiagonals","isCastle$1","isF1Checked","isG1Checked","isD1Checked","isC1Checked","isF8Checked","isG8Checked","isD8Checked","isC8Checked","dragStart","setTimeout","classList","add","dragEnd","remove","dropPiece","boardHtml","validator","pieceBeingDragged","querySelector","parentElement","id","destSquare","ValidateMove","enPassantSquare","documentHTML","enPassantedSquareId","getEnPassantSquare","innerHTML","appendChild","KingsOrigin","KingsDest","RooksOrigin","RooksDest","getCastlingSquares","Rook","firstElementChild","temporaryReplaceSquare","temporaryReplaceRankElement","promotionRank","promotionRankElement","temporaryReplaceSquareRank","list","whitePromotionHtml","pieceImages","blackPromotionHtml","Wrapper","document","createElement","createPawnPromotionHtmlElement","replaceChild","addEventListener","target","setAttribute","PromotePawn","AnalysisBoard","hostRef","registerInstance","light","dark","analysisBoardContainer","generateChessBoard","pieces","querySelectorAll","squares","forEach","documentHtml","contains","otherHighlightedPiece","parentSquare","onPieceClick","preventDefault","ref","el","style","PieceType","getPieceImage","type","whitePawn","P","blackPawn","p","whiteRook","R","blackRook","r","whiteKnight","N","blackKnight","n","whiteBishop","B","blackBishop","whiteQueen","Q","blackQueen","q","whiteKing","K","blackKing","k","fen","rows","split","board","Object","assign","currentSquare","currentFile","currentRank","match","empties","lightSquareColor","darkSquareColor","colorArray","currentColorIndex","html"],"sourceRoot":""}